<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Fluent Python (3)：面向对象 | PrintXHL | 我就想做一点微小的工作</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#2361b6">
    
    
    <meta name="keywords" content="Python">
    <meta name="description" content="对象引用、可变性和垃圾回收变量不是盒子一言以蔽之，变量名是存在于内存中真实对象的一个标签而已，一个对象可以贴多个标签。 标识、相等性和别名在==和is之间选择 ==运算符比较两个对象中保存的值，而is比较对象的id 通常关注对象值而不是标识，所以==出现频率比is高。最常使用is检测变量绑定值是不是None，x is None is运算符比==速度快，因为它不重载，所以不用寻找并调用特殊方法。而=">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Fluent Python (3)：面向对象">
<meta property="og:url" content="http://printxhl.com/2018/05/30/Python-FlunetPython-class/index.html">
<meta property="og:site_name" content="PrintXHL">
<meta property="og:description" content="对象引用、可变性和垃圾回收变量不是盒子一言以蔽之，变量名是存在于内存中真实对象的一个标签而已，一个对象可以贴多个标签。 标识、相等性和别名在==和is之间选择 ==运算符比较两个对象中保存的值，而is比较对象的id 通常关注对象值而不是标识，所以==出现频率比is高。最常使用is检测变量绑定值是不是None，x is None is运算符比==速度快，因为它不重载，所以不用寻找并调用特殊方法。而=">
<meta property="og:image" content="http://oj8vattcf.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB.PNG">
<meta property="og:updated_time" content="2018-03-23T02:14:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fluent Python (3)：面向对象">
<meta name="twitter:description" content="对象引用、可变性和垃圾回收变量不是盒子一言以蔽之，变量名是存在于内存中真实对象的一个标签而已，一个对象可以贴多个标签。 标识、相等性和别名在==和is之间选择 ==运算符比较两个对象中保存的值，而is比较对象的id 通常关注对象值而不是标识，所以==出现频率比is高。最常使用is检测变量绑定值是不是None，x is None is运算符比==速度快，因为它不重载，所以不用寻找并调用特殊方法。而=">
<meta name="twitter:image" content="http://oj8vattcf.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB.PNG">
    
        <link rel="alternate" type="application/atom+xml" title="PrintXHL" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.13">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">谢海练</h5>
          <a href="mailto:xiehailian66@126.com" title="xiehailian66@126.com" class="mail">xiehailian66@126.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/python"  >
                <i class="icon icon-lg icon-code"></i>
                Python
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/data"  >
                <i class="icon icon-lg icon-database"></i>
                Data
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/book"  >
                <i class="icon icon-lg icon-book"></i>
                Book
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/xiehailian" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Fluent Python (3)：面向对象</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Fluent Python (3)：面向对象</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-05-30T06:54:59.526Z" itemprop="datePublished" class="page-time">
  2018-05-30
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对象引用、可变性和垃圾回收"><span class="post-toc-number">1.</span> <span class="post-toc-text">对象引用、可变性和垃圾回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量不是盒子"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">变量不是盒子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标识、相等性和别名"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">标识、相等性和别名</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在-和is之间选择"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">在==和is之间选择</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#元组的相对不可变性"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">元组的相对不可变性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#默认做浅复制"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">默认做浅复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数的参数作为引用时"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">函数的参数作为引用时</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不要使用可变类型作为参数的默认值"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">不要使用可变类型作为参数的默认值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#防御可变参数"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">防御可变参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#del和垃圾回收"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">del和垃圾回收</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#弱引用"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">弱引用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#WeakValueDictionary简介"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">WeakValueDictionary简介</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#弱引用的局限"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">弱引用的局限</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#符合Python风格的对象"><span class="post-toc-number">2.</span> <span class="post-toc-text">符合Python风格的对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象表现形式"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">对象表现形式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#向量类"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">向量类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#备选构造方法"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">备选构造方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#classmethod与staticmethod"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">classmethod与staticmethod</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#格式化显示"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">格式化显示</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可散列的Vector2d"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">可散列的Vector2d</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Python的私有属性和受保护属性"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">Python的私有属性和受保护属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-slots-类属性节省空间"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">使用__slots__类属性节省空间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#覆盖类属性"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">覆盖类属性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列的修改、散列和切片"><span class="post-toc-number">3.</span> <span class="post-toc-text">序列的修改、散列和切片</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector类：用户定义的序列类型"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Vector类：用户定义的序列类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector类第1版：与Vector2d类兼容"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Vector类第1版：与Vector2d类兼容</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector类第2版：可切片的序列"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Vector类第2版：可切片的序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector类第3版：动态存取属性"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">Vector类第3版：动态存取属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector第4版：散列和快速等值测试"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">Vector第4版：散列和快速等值测试</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector第5版：格式化"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">Vector第5版：格式化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#接口：从协议到抽象基类"><span class="post-toc-number">4.</span> <span class="post-toc-text">接口：从协议到抽象基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Python文化中的接口和协议"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Python文化中的接口和协议</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Python喜欢序列"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Python喜欢序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用猴子补丁在运行时实现协议"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">使用猴子补丁在运行时实现协议</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#鸭子类型-vs-白鹅类型"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">鸭子类型 vs  白鹅类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义抽象基类的子类"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">定义抽象基类的子类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标准库中的抽象基类"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">标准库中的抽象基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#collections-abc模块中的抽象基类"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">collections.abc模块中的抽象基类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#抽象基类的数字塔"><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">抽象基类的数字塔</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义并使用一个抽象基类"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">定义并使用一个抽象基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#抽象基类句法详解"><span class="post-toc-number">4.7.1.</span> <span class="post-toc-text">抽象基类句法详解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义Tombola抽象基类的子类"><span class="post-toc-number">4.7.2.</span> <span class="post-toc-text">定义Tombola抽象基类的子类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Tombola的虚拟子类"><span class="post-toc-number">4.7.3.</span> <span class="post-toc-text">Tombola的虚拟子类</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Tombola子类的测试方法"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">Tombola子类的测试方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Python使用register的方式"><span class="post-toc-number">4.9.</span> <span class="post-toc-text">Python使用register的方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承的优缺点"><span class="post-toc-number">5.</span> <span class="post-toc-text">继承的优缺点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#子类化内置类型很麻烦"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">子类化内置类型很麻烦</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承和方法解析顺序"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">多重继承和方法解析顺序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#处理多重继承"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">处理多重继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正确重载运算符"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">正确重载运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#运算符重载基础"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">运算符重载基础</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一元运算符"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">一元运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重载向量加法运算符"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">重载向量加法运算符+</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重载标量乘法运算符"><span class="post-toc-number">5.8.</span> <span class="post-toc-text">重载标量乘法运算符*</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#众多比较运算符"><span class="post-toc-number">5.9.</span> <span class="post-toc-text">众多比较运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#增量赋值运算符"><span class="post-toc-number">5.10.</span> <span class="post-toc-text">增量赋值运算符</span></a></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-Python-FlunetPython-class"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Fluent Python (3)：面向对象</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-05-30 14:54:59" datetime="2018-05-30T06:54:59.526Z"  itemprop="datePublished">2018-05-30</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="对象引用、可变性和垃圾回收"><a href="#对象引用、可变性和垃圾回收" class="headerlink" title="对象引用、可变性和垃圾回收"></a>对象引用、可变性和垃圾回收</h2><h3 id="变量不是盒子"><a href="#变量不是盒子" class="headerlink" title="变量不是盒子"></a>变量不是盒子</h3><p>一言以蔽之，变量名是存在于内存中真实对象的一个标签而已，一个对象可以贴多个标签。</p>
<h3 id="标识、相等性和别名"><a href="#标识、相等性和别名" class="headerlink" title="标识、相等性和别名"></a>标识、相等性和别名</h3><h4 id="在-和is之间选择"><a href="#在-和is之间选择" class="headerlink" title="在==和is之间选择"></a>在==和is之间选择</h4><ul>
<li><code>==</code>运算符比较两个对象中保存的值，而<code>is</code>比较对象的<code>id</code></li>
<li>通常关注对象值而不是标识，所以<code>==</code>出现频率比<code>is</code>高。最常使用<code>is</code>检测变量绑定值是不是<code>None</code>，<code>x is None</code></li>
<li><code>is</code>运算符比<code>==</code>速度快，因为它不重载，所以不用寻找并调用特殊方法。而<code>==</code>是语法糖，等同于<code>a.__eq__(b)</code></li>
</ul>
<h4 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>]) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2 </div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>]) </div><div class="line"><span class="number">4302515784</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1</div><div class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">99</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>]) </div><div class="line"><span class="number">4302515784</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2 </div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>元组的值会随着引用对象的变化而变，元组中不可变的是元素的标识。</p>
<h3 id="默认做浅复制"><a href="#默认做浅复制" class="headerlink" title="默认做浅复制"></a>默认做浅复制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)  <span class="comment"># 1 </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1 </div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1   <span class="comment"># 2</span></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<ol>
<li><code>l2 = list(l1)</code>等价于<code>l2 = l1[:]</code>等价于<code>l2 = l1.copy()</code></li>
<li><code>list(l1)</code>创建<code>l1</code>的副本，二者值相等，但是指代不同的对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></div><div class="line">    </div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></div><div class="line">		<span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">			self.passengers = []</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			self.passengers = list(passengers)</div><div class="line">            </div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></div><div class="line">		self.passengers.append(name)</div><div class="line">        </div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></div><div class="line">		self.passengers.remove(name)</div><div class="line">        </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy.copy(bus1)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = copy.deepcopy(bus1)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1), id(bus2), id(bus3)</div><div class="line">(<span class="number">4301498296</span>, <span class="number">4301499416</span>, <span class="number">4301499752</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Bill'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</div><div class="line">[<span class="string">'Alice'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>] </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1.passengers), id(bus2.passengers), id(bus3.passengers) <span class="comment"># 1</span></div><div class="line">(<span class="number">4302658568</span>, <span class="number">4302658568</span>, <span class="number">4302657800</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</div><div class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]  <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<ol>
<li><code>bus1</code>和<code>bus2</code>共享一个列表对象，因为<code>bus2</code>是<code>bus1</code>的浅复制副本</li>
<li><code>bus3</code>是<code>bus1</code>的深复制副本，因为它的<code>passengers</code>属性指代另一个列表</li>
</ol>
<h3 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h3><h4 id="不要使用可变类型作为参数的默认值"><a href="#不要使用可变类型作为参数的默认值" class="headerlink" title="不要使用可变类型作为参数的默认值"></a>不要使用可变类型作为参数的默认值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span> </div><div class="line">	self.passengers = passengers </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></div><div class="line">	self.passengers.append(name) </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></div><div class="line">	self.passengers.remove(name)</div></pre></td></tr></table></figure>
<p>本例中使用列表作为默认值，当不同实例按默认值初始化时，将导致不同实例的<code>passengers</code>指代同一个列表</p>
<h4 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></div><div class="line">		<span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">			self.passengers = []  <span class="comment"># 1</span></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			self.passengers = list(passengers)  <span class="comment"># 2</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></div><div class="line">		self.passengers.append(name)</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></div><div class="line">		self.passengers.remove(name)</div></pre></td></tr></table></figure>
<ol>
<li>当<code>passengers</code>为<code>None</code>时，创建一个新的空列表，防御可变参数</li>
<li>不要影响初始化校车时传入的参数，如果不是列表就转换成列表</li>
</ol>
<h3 id="del和垃圾回收"><a href="#del和垃圾回收" class="headerlink" title="del和垃圾回收"></a>del和垃圾回收</h3><ul>
<li><code>del</code>语句删除名称，而不是对象。<code>del</code>命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用</li>
<li>如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而把它们都销毁</li>
<li>在<code>CPython</code>中，垃圾回收使用的主要算法是<strong>引用计数</strong>。每个对象都会统计有多少引用指向自己，当引用计数归零时，对象立即被销毁：<code>CPython</code>会在对象上调用<code>__del__</code>方法，然后释放分配给对象的内存</li>
</ul>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)  <span class="comment"># 1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wref</div><div class="line">&lt;weakref at <span class="number">0x100637598</span>; to <span class="string">'set'</span> at <span class="number">0x100636748</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 2</span></div><div class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 3</span></div><div class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="keyword">None</span>  <span class="comment"># 4</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="keyword">None</span> </div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<ol>
<li>创建弱引用对象<code>wref</code>，弱应用不会增加对象的引用数量，若引用并不会妨碍所指对象被当作垃圾回收</li>
<li>调用<code>wref()</code>返回的是被引用对象，<code>{0, 1}</code>。因为这是控制台会话，所以<code>{0, 1}</code>会绑定给<code>_</code>变量</li>
<li><code>a_set</code>不再指代<code>{0, 1}</code>集合，因此集合的引用数量减少了，但是<code>_</code>变量仍然指代它</li>
<li>计算这个表达式时，<code>{0, 1}</code>存在，因此<code>wref()</code>不是<code>None</code>。但是随后<code>_</code>绑定到结果值<code>False</code>。现在<code>{0, 1}</code>没有强引用了</li>
</ol>
<h4 id="WeakValueDictionary简介"><a href="#WeakValueDictionary简介" class="headerlink" title="WeakValueDictionary简介"></a>WeakValueDictionary简介</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kind)</span>:</span></div><div class="line">        self.kind = kind</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'Cheese(%r)'</span> % self.kind</div><div class="line">        </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">'Red Leicester'</span>), Cheese(<span class="string">'Tilsit'</span>),</div><div class="line"><span class="meta">... </span>Cheese(<span class="string">'Brie'</span>), Cheese(<span class="string">'Parmesan'</span>)]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:</div><div class="line"><span class="meta">... </span>stock[cheese.kind] = cheese </div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</div><div class="line">[<span class="string">'Brie'</span>, <span class="string">'Parmesan'</span>, <span class="string">'Red Leicester'</span>, <span class="string">'Tilsit'</span>] </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</div><div class="line">[<span class="string">'Parmesan'</span>] </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</div><div class="line">[]</div></pre></td></tr></table></figure>
<h4 id="弱引用的局限"><a href="#弱引用的局限" class="headerlink" title="弱引用的局限"></a>弱引用的局限</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></div><div class="line">	<span class="string">"""list的子类，实例可以作为弱引用的目标"""</span></div><div class="line">    </div><div class="line">a_list = MyList(range(<span class="number">10</span>))</div><div class="line"><span class="comment"># a_list可以作为弱引用的目标</span></div><div class="line">wref_to_a_list = weakref.ref(a_list)</div></pre></td></tr></table></figure>
<p>不是每个Python对象都可以作为弱引用的目标，基本的<code>list</code>和<code>dict</code>实例不能作为所指的对象，但是它们的子类可以解决这个问题。</p>
<h2 id="符合Python风格的对象"><a href="#符合Python风格的对象" class="headerlink" title="符合Python风格的对象"></a>符合Python风格的对象</h2><h3 id="对象表现形式"><a href="#对象表现形式" class="headerlink" title="对象表现形式"></a>对象表现形式</h3><ul>
<li><code>repr()</code>：以便于开发者理解的方式返回对象的字符串表示形式</li>
<li><code>str()</code>：以便于用户理解的方式返回对象的字符串表示形式</li>
</ul>
<h3 id="向量类"><a href="#向量类" class="headerlink" title="向量类"></a>向量类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></div><div class="line">    typecode = <span class="string">'d'</span>  <span class="comment"># 1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        self.x = float(x)    </div><div class="line">        self.y = float(y)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        class_name = type(self).__name__</div><div class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)  <span class="comment"># 2</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> str(tuple(self))  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</div><div class="line">                bytes(array(self.typecode, self)))  <span class="comment"># 3</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> tuple(self) == tuple(other) </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> bool(abs(self))</div></pre></td></tr></table></figure>
<ol>
<li><p><code>typecode</code>是类属性，在<code>Vector2d</code>实例和字节序列之间转换时使用</p>
<p>| Type code | C Type             | Python Type       | Minimum size in bytes | Notes |<br>| ——— | —————— | —————– | ——————— | —– |<br>| <code>&#39;b&#39;</code>     | signed char        | int               | 1                     |       |<br>| <code>&#39;B&#39;</code>     | unsigned char      | int               | 1                     |       |<br>| <code>&#39;u&#39;</code>     | Py_UNICODE         | Unicode character | 2                     | (1)   |<br>| <code>&#39;h&#39;</code>     | signed short       | int               | 2                     |       |<br>| <code>&#39;H&#39;</code>     | unsigned short     | int               | 2                     |       |<br>| <code>&#39;i&#39;</code>     | signed int         | int               | 2                     |       |<br>| <code>&#39;I&#39;</code>     | unsigned int       | int               | 2                     |       |<br>| <code>&#39;l&#39;</code>     | signed long        | int               | 4                     |       |<br>| <code>&#39;L&#39;</code>     | unsigned long      | int               | 4                     |       |<br>| <code>&#39;q&#39;</code>     | signed long long   | int               | 8                     | (2)   |<br>| <code>&#39;Q&#39;</code>     | unsigned long long | int               | 8                     | (2)   |<br>| <code>&#39;f&#39;</code>     | float              | float             | 4                     |       |<br>| <code>&#39;d&#39;</code>     | double             | float             | 8                     |       |</p>
</li>
<li><p><code>__repr__</code>方法使用<code>{!r}</code>获取各个分量的表示形式，然后插值，构成一个字符串。因为<code>Vector2d</code>实例是可迭代对象，所以<code>*self</code>会把<code>x</code>和<code>y</code>分量提供给<code>format</code>函数</p>
</li>
<li><p>迭代<code>Vector2d</code>实例，得到一个数组，再把数组转换成字节序列。<code>ord()</code>是<code>chr()</code>的配对函数，以一个字符作为参数，返回对应的<code>ASCII</code>数值</p>
</li>
</ol>
<h3 id="备选构造方法"><a href="#备选构造方法" class="headerlink" title="备选构造方法"></a>备选构造方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@classmethod  # 1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span>  </div><div class="line">    typecode = chr(octets[<span class="number">0</span>])  <span class="comment"># 2</span></div><div class="line">    memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)  <span class="comment"># 3</span></div><div class="line">    <span class="keyword">return</span> cls(*memv)  <span class="comment"># 4</span></div></pre></td></tr></table></figure>
<ol>
<li>使用<code>classmethod</code>装饰器定义备选构造方法，可以使用<code>Vector2d.frombytes(octets)</code>把字节序列转换成<code>Vector2d</code>实例。</li>
<li>从第一个字节中读取<code>typecode</code></li>
<li>使用传入的<code>octets</code>字节序列创建一个<code>memoryview</code>，然后使用<code>typecode</code>转换</li>
<li>拆包转换后的<code>memoryview</code>，得到构造方法所需的一对参数</li>
</ol>
<h3 id="classmethod与staticmethod"><a href="#classmethod与staticmethod" class="headerlink" title="classmethod与staticmethod"></a>classmethod与staticmethod</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></div><div class="line">    </div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></div><div class="line">        <span class="keyword">return</span> args</div><div class="line">    </div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></div><div class="line">        <span class="keyword">return</span> args</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()  </div><div class="line">(&lt;class '__main__.Demo'&gt;,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">'spam'</span>)</div><div class="line">(&lt;class '__main__.Demo'&gt;, 'spam')</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()   </div><div class="line">()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">'spam'</span>)</div><div class="line">(<span class="string">'spam'</span>,)</div></pre></td></tr></table></figure>
<ul>
<li><code>classmethod</code>，定义操作类而不是操作实例的方法，最常见的用途是定义备选构造方法</li>
<li><code>staticmethod</code>，静态方法其实就是普通的函数，只是碰巧在类的定义中，而不是在模块层定义。有时函数虽然从不处理类，但是函数的功能和类密切相关，想把它放在近处让代码好看点，并不是特别有用</li>
</ul>
<h3 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h3><blockquote>
<p><a href="https://docs.python.org/3/library/string.html#formatspec" target="_blank" rel="external">str.format()</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></div><div class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):  <span class="comment"># 1</span></div><div class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]  </div><div class="line">            coords = (abs(self), self.angle())  </div><div class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span>  <span class="comment"># 2</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            coords = self  </div><div class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span>  </div><div class="line">        components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)  </div><div class="line">        <span class="keyword">return</span> outer_fmt.format(*components)  </div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'p'</span>)</div><div class="line"><span class="string">'&lt;1.4142135623730951, 0.7853981633974483&gt;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'.3ep'</span>)</div><div class="line"><span class="string">'&lt;1.414e+00, 7.854e-01&gt;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'0.5fp'</span>)</div><div class="line"><span class="string">'&lt;1.41421, 0.78540&gt;'</span></div></pre></td></tr></table></figure>
<ol>
<li>如果格式代码以<code>p</code>结尾，使用极坐标。如果不是，则使用直角坐标</li>
<li>定义格式化的模板，极坐标用尖括号，直角坐标用圆括号</li>
</ol>
<h3 id="可散列的Vector2d"><a href="#可散列的Vector2d" class="headerlink" title="可散列的Vector2d"></a>可散列的Vector2d</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></div><div class="line">    typecode = <span class="string">'d'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        self.__x = float(x)  <span class="comment"># 1</span></div><div class="line">        self.__y = float(y)</div><div class="line"></div><div class="line"><span class="meta">    @property  # 2</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> self.__x  </div><div class="line"></div><div class="line"><span class="meta">    @property  </span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__y</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        class_name = type(self).__name__</div><div class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> str(tuple(self))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</div><div class="line">                bytes(array(self.typecode, self)))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)  <span class="comment"># 3</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> bool(abs(self))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></div><div class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</div><div class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</div><div class="line">            coords = (abs(self), self.angle())</div><div class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            coords = self</div><div class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></div><div class="line">        components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</div><div class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></div><div class="line">        typecode = chr(octets[<span class="number">0</span>])</div><div class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</div><div class="line">        <span class="keyword">return</span> cls(*memv)</div></pre></td></tr></table></figure>
<ol>
<li>使用两个前导下划线，把属性标记为私有的</li>
<li><code>@property</code>装饰器把读值方法标记为特性</li>
<li>要创建可散列的类型，只需正确地实现<code>__hash__</code>和<code>__eq__</code>方法，但是实例的散列值绝不应该变化，因此使用了只读属性。最好使用位运算异或<code>^</code>混合各分量的散列值。</li>
</ol>
<h3 id="Python的私有属性和受保护属性"><a href="#Python的私有属性和受保护属性" class="headerlink" title="Python的私有属性和受保护属性"></a>Python的私有属性和受保护属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</div><div class="line">&#123;<span class="string">'_Vector2d__y'</span>: <span class="number">4.0</span>, <span class="string">'_Vector2d__x'</span>: <span class="number">3.0</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x</div><div class="line"><span class="number">3.0</span></div></pre></td></tr></table></figure>
<ul>
<li><code>self.__x</code>被称为私有属性，这个私有属性硬要通过实例来访问的话，可以使用<code>v1._Vector2d__x</code></li>
<li><code>self._x</code>被称为受保护属性，名称不会被解释器改写</li>
</ul>
<h3 id="使用-slots-类属性节省空间"><a href="#使用-slots-类属性节省空间" class="headerlink" title="使用__slots__类属性节省空间"></a>使用<code>__slots__</code>类属性节省空间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></div><div class="line">	__slots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</div><div class="line">    </div><div class="line">    typecode = <span class="string">'d'</span></div></pre></td></tr></table></figure>
<ul>
<li>在类中定义<code>__slots__</code>属性的目的是告诉解释器，这个类的所有属性都在这了。这样Python会在各个实例中使用类似元组的结构存储实例变量，从避免使用消耗内存的<code>__dict__</code>属性。如果有数百万个实例同时活动，这样做能节省大量的内存</li>
<li>每个子类都要定义<code>__slots__</code>属性，因为解释器会忽略继承的<code>__slots__</code>属性</li>
<li>实例只能拥有<code>__slots__</code>中列出的属性，除非把<code>__dict__</code>加入<code>__slots__</code>中，这样做就失去了节省内存的功效</li>
<li>如果不把<code>__weakref__</code>加入<code>__slots__</code>，实例就不能作为弱引用的目标</li>
</ul>
<h3 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">1.1</span>, <span class="number">2.2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd = bytes(v1)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dumpdb</div><div class="line"><span class="string">'d\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpd) </div><div class="line"><span class="number">17</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>v1.typecode = <span class="string">'f'</span> <span class="comment"># 2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf = bytes(v1)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf</div><div class="line"><span class="string">b'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpf) </div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode <span class="comment"># 2</span></div><div class="line"><span class="string">'d'</span></div></pre></td></tr></table></figure>
<ol>
<li>把<code>v1</code>实例的<code>typecode</code>属性设为<code>f</code></li>
<li><code>Vector2d.typecode</code>属性的值不变，只有<code>v1</code>实例的<code>typecode</code>属性使用<code>f</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector2d_v3 <span class="keyword">import</span> Vector2d</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ShortVector2d</span><span class="params">(Vector2d)</span>:</span>  <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>	typecode = <span class="string">'f'</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sv = ShortVector2d(<span class="number">1</span>/<span class="number">11</span>, <span class="number">1</span>/<span class="number">27</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sv</div><div class="line">ShortVector2d(<span class="number">0.09090909090909091</span>, <span class="number">0.037037037037037035</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(bytes(sv)) </div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<ol>
<li>创建一个子类，只用于覆盖typecode类属性</li>
</ol>
<h2 id="序列的修改、散列和切片"><a href="#序列的修改、散列和切片" class="headerlink" title="序列的修改、散列和切片"></a>序列的修改、散列和切片</h2><h3 id="Vector类：用户定义的序列类型"><a href="#Vector类：用户定义的序列类型" class="headerlink" title="Vector类：用户定义的序列类型"></a>Vector类：用户定义的序列类型</h3><h3 id="Vector类第1版：与Vector2d类兼容"><a href="#Vector类第1版：与Vector2d类兼容" class="headerlink" title="Vector类第1版：与Vector2d类兼容"></a>Vector类第1版：与Vector2d类兼容</h3><p>序列类型的构造方法最好接受可迭代的对象参数，因为所有内置的序列类型都是这样做的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</div><div class="line"><span class="keyword">import</span> reprlib</div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></div><div class="line">    typecode = <span class="string">'d'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></div><div class="line">        self._components = array(self.typecode, components)  <span class="comment"># &lt;1&gt;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> iter(self._components)  <span class="comment"># &lt;2&gt;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        components = reprlib.repr(self._components)  <span class="comment"># &lt;3&gt;</span></div><div class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]  <span class="comment"># &lt;4&gt;</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> str(tuple(self))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</div><div class="line">                bytes(self._components))  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> bool(abs(self))</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></div><div class="line">        typecode = chr(octets[<span class="number">0</span>])</div><div class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</div><div class="line">        <span class="keyword">return</span> cls(memv)  <span class="comment"># &lt;5&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li><code>self._components</code>是受保护的实例属性，把<code>Vector</code>的分量保存在一个数组中</li>
<li>为了迭代，使用<code>self._components</code>构建一个迭代器</li>
<li>使用<code>reprlib.repr()</code>函数获取<code>self._compoents</code>的有限长度表示形式，如<code>array(&#39;d&#39;,[0,1,2,3,4,...]</code></li>
<li>把字符串插入<code>Vector</code>的构造方法调用之前，去掉前面的<code>array(&#39;d</code>和后面的<code>)</code>。</li>
<li>直接把<code>memoryview</code>传给构造方法，不用像前面那样使用<code>*</code>拆包</li>
</ol>
<h3 id="Vector类第2版：可切片的序列"><a href="#Vector类第2版：可切片的序列" class="headerlink" title="Vector类第2版：可切片的序列"></a>Vector类第2版：可切片的序列</h3><p>在面向对象编程中，协议是非正式的接口，只在文档中定义不在代码中定义。例如，Python的<strong>序列协议</strong>只需要实现<code>__len__</code>和<code>__getitem__</code>两个方法。任何类只要实现了这两个方法，就可切片。协议是非正式的，没有强制力，为了支持迭代，只需实现<code>__getitem__</code>方法，没必要提供<code>__len__</code>方法。所以<strong>鸭子类型</strong>的意思是，只要这个类实现了<code>__getitem__</code>方法，那么我们就说它是序列，因为它的行为像序列，这才是重点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span>  </div><div class="line">    <span class="keyword">return</span> len(self._components)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></div><div class="line">    cls = type(self)  <span class="comment"># 1</span></div><div class="line">    <span class="keyword">if</span> isinstance(index, slice):   <span class="comment"># 2</span></div><div class="line">        <span class="keyword">return</span> cls(self._components[index])  </div><div class="line">    <span class="keyword">elif</span> isinstance(index, numbers.Integral):   <span class="comment"># 3</span></div><div class="line">        <span class="keyword">return</span> self._components[index]  </div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span>  </div><div class="line">        <span class="keyword">raise</span> TypeError(msg.format(cls=cls))</div></pre></td></tr></table></figure>
<ol>
<li>获取实例所属的类，供后面使用</li>
<li>如果<code>index</code>参数的值是<code>slice</code>对象，调用类的构造方法，使用<code>_components</code>数组的切片构建一个新的<code>Vector</code>实例。</li>
<li>如果<code>index</code>是<code>int</code>或其他整数类型，那就返回<code>_components</code>中相应的元素</li>
</ol>
<h3 id="Vector类第3版：动态存取属性"><a href="#Vector类第3版：动态存取属性" class="headerlink" title="Vector类第3版：动态存取属性"></a>Vector类第3版：动态存取属性</h3><p>使用单个字母访问前几个分量。</p>
<p>在<code>Vector2d</code>中，使用 <code>@property</code>装饰器可以把<code>x</code>和<code>y</code>标记为只读特性。在<code>Vector</code>中也可以这样做，但是太麻烦，使用<code>__getattr__</code>更方便。属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对<code>my_obj.x</code>表达式，解释器会先检查<strong>实例</strong>有没有<code>x</code>属性，如果没有再检查<strong>类</strong><code>my_obj.__class__</code>中查找，如果没有再顺着继承树查找，实在找不到就调用<code>my_obj</code>所属类中定义的<code>__getattr__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">shortcut_names = <span class="string">'xyzt'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">    cls = type(self)  </div><div class="line">    <span class="keyword">if</span> len(name) == <span class="number">1</span>:  </div><div class="line">        pos = cls.shortcut_names.find(name)   <span class="comment"># 1</span></div><div class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):  </div><div class="line">            <span class="keyword">return</span> self._components[pos]</div><div class="line">    msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span>  </div><div class="line">    <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">    cls = type(self)</div><div class="line">    <span class="keyword">if</span> len(name) == <span class="number">1</span>:  </div><div class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_names:   <span class="comment"># 2</span></div><div class="line">            error = <span class="string">'readonly attribute &#123;attr_name!r&#125;'</span></div><div class="line">        <span class="keyword">elif</span> name.islower():  </div><div class="line">            error = <span class="string">"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;"</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            error = <span class="string">''</span>  </div><div class="line">        <span class="keyword">if</span> error:  </div><div class="line">            msg = error.format(cls_name=cls.__name__, attr_name=name)</div><div class="line">            <span class="keyword">raise</span> AttributeError(msg)</div><div class="line">    super().__setattr__(name, value)  <span class="comment"># 3</span></div></pre></td></tr></table></figure>
<ol>
<li>查找那个字母的位置，如果位置落在范围内，返回数组对应的元素</li>
<li>如果<code>name</code>是<code>xyzt</code>中的一个，设置特殊的错误信息，避免用户私自设置类的属性</li>
<li>在超类上调用<code>__setattr__</code>方法。<code>super()</code>函数用于动态访问超类的方法，使用这个函数把子类的方法的某些任务委托给超类中适当的方法。</li>
</ol>
<h3 id="Vector第4版：散列和快速等值测试"><a href="#Vector第4版：散列和快速等值测试" class="headerlink" title="Vector第4版：散列和快速等值测试"></a>Vector第4版：散列和快速等值测试</h3><p>通过实现<code>__hash__</code>方法，加上现有的<code>__eq__</code>方法，把<code>Vector</code>实例变成可以散列的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># hashes = (hash(x) for x in self)</span></div><div class="line">    hashes = map(hash, self._components)   <span class="comment"># 1</span></div><div class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)  <span class="comment"># 2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">    <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></div><div class="line">            all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</div></pre></td></tr></table></figure>
<ol>
<li><code>Python 2</code>中使用<code>map</code>函数效率低些，因为<code>map</code>函数要使用结果构建一个列表，但在<code>Python 3</code>中，<code>map</code>函数是惰性的，它会创建一个生成器，按需产出结果，因此节省内存</li>
<li>把<code>hashes</code>提供给<code>reduce</code>函数，使用<code>xor</code>函数计算聚合的散列值，第三个参数，0是初始值。对于<code>+</code>、<code>|</code>和<code>^</code>来说，初始值应该是0。对于<code>*</code>和<code>&amp;</code>来说，初始值应该是1。</li>
<li><code>zip</code>函数生成一个由元组构成的生成器，元组中的元素来自各个可迭代对象。前面比较长度测试时有必要的，因为一旦有一个输入耗尽，<code>zip</code>函数会立即停止生成值，而且不发出警告，你就发现不了问题了。只要有一次比较的结果是<code>False</code>，<code>all</code>函数就返回<code>False</code>。</li>
</ol>
<h3 id="Vector第5版：格式化"><a href="#Vector第5版：格式化" class="headerlink" title="Vector第5版：格式化"></a>Vector第5版：格式化</h3><p>因为<code>Vector</code>类支持<code>n</code>个维度，而超过四维后，球体变成超球体。所以<code>Vector</code>类的<code>__format__</code>方法就要使用球面坐标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self, n)</span>:</span>   <span class="comment"># 1</span></div><div class="line">    r = math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self[n:]))</div><div class="line">    a = math.atan2(r, self[n<span class="number">-1</span>])</div><div class="line">    <span class="keyword">if</span> (n == len(self) - <span class="number">1</span>) <span class="keyword">and</span> (self[<span class="number">-1</span>] &lt; <span class="number">0</span>):</div><div class="line">        <span class="keyword">return</span> math.pi * <span class="number">2</span> - a</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> a</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">angles</span><span class="params">(self)</span>:</span>  </div><div class="line">    <span class="keyword">return</span> (self.angle(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, len(self)))  <span class="comment"># 2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></div><div class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'h'</span>):  <span class="comment"># hyperspherical coordinates</span></div><div class="line">        fmt_spec = fmt_spec[:<span class="number">-1</span>]</div><div class="line">        coords = itertools.chain([abs(self)], self.angles())  <span class="comment"># 3</span></div><div class="line">        outer_fmt = <span class="string">'&lt;&#123;&#125;&gt;'</span>  </div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        coords = self</div><div class="line">        outer_fmt = <span class="string">'(&#123;&#125;)'</span>  </div><div class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)  </div><div class="line">    <span class="keyword">return</span> outer_fmt.format(<span class="string">', '</span>.join(components))</div></pre></td></tr></table></figure>
<ol>
<li>使用公式计算某个角座标</li>
<li>创建生成器表达式，按需计算所有角座标</li>
<li>使用<code>itertools.chain</code>函数生成器表达式，无缝接待向量的模和各个角座标</li>
</ol>
<h2 id="接口：从协议到抽象基类"><a href="#接口：从协议到抽象基类" class="headerlink" title="接口：从协议到抽象基类"></a>接口：从协议到抽象基类</h2><h3 id="Python文化中的接口和协议"><a href="#Python文化中的接口和协议" class="headerlink" title="Python文化中的接口和协议"></a>Python文化中的接口和协议</h3><ul>
<li><strong>接口</strong>：抽象类就是接口，实现特定角色的方法集合，如文件类对象或可迭代对象，一个类可能会实现多个接口，从而让实例扮演多个角色</li>
<li><strong>协议</strong>：协议是接口，但不是正式的，只由文档和约定定义，因此协议不能像正式接口那样施加限制，一个类可能只实现了部分接口，这是允许的</li>
</ul>
<h3 id="Python喜欢序列"><a href="#Python喜欢序列" class="headerlink" title="Python喜欢序列"></a>Python喜欢序列</h3><p>Python数据模型的哲学是尽量支持基本协议。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, pos)</span>:</span></div><div class="line">        <span class="keyword">return</span> range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>)[pos]</div></pre></td></tr></table></figure>
<p><code>Foo</code>类没有继承<code>abs.Sequence</code>，而且只实现了序列协议的一个方法<code>__getitem__</code>，这样足够访问元素、迭代和使用<code>in</code>运算符了。鉴于<strong>序列协议</strong>的重要性，如果没有<code>__iter__</code>和<code>__contains__</code>方法，Python会调用<code>__getitem__</code>方法，设法让迭代和<code>in</code>运算符可用。</p>
<h3 id="使用猴子补丁在运行时实现协议"><a href="#使用猴子补丁在运行时实现协议" class="headerlink" title="使用猴子补丁在运行时实现协议"></a>使用猴子补丁在运行时实现协议</h3><p>如果遵守既定协议，很可能增加利用现有的标准库和第三方代码的可能性，这得益于鸭子类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_card</span><span class="params">(deck, position, card)</span>:</span>  <span class="comment"># 1</span></div><div class="line"><span class="meta">... </span>	deck._cards[position] = card</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FrenchDeck.__setitem__ = set_card   <span class="comment"># 2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)  <span class="comment"># 3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:<span class="number">5</span>][Card(rank=<span class="string">'3'</span>, suit=<span class="string">'hearts'</span>), Card(rank=<span class="string">'4'</span>, suit=<span class="string">'diamonds'</span>), Card(rank=<span class="string">'4'</span>,suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'7'</span>, suit=<span class="string">'hearts'</span>), Card(rank=<span class="string">'9'</span>, suit=<span class="string">'spades'</span>)]</div></pre></td></tr></table></figure>
<ol>
<li>每个Python方法说白了就是普通函数，把第一个参数命名为<code>self</code>只是一种约定，按照文档那样应该使用<code>set_card(self, key, value</code>。</li>
<li>Python是<strong>动态语言</strong>，可以在运行时提供<code>__setitem__</code>方法，实现可变序列协议。这种在运行时修改类或模块而不改变源码的技术叫做<strong>猴子补丁</strong>，但是打补丁的代码必须与要打补丁的程序耦合紧密，而且要处理隐藏和没有文档的部分。</li>
<li><code>random.shuffle</code>函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。这就是所谓的<strong>鸭子类型</strong>：对象的类型无关紧要，只要实现了特定的协议即可。</li>
</ol>
<h3 id="鸭子类型-vs-白鹅类型"><a href="#鸭子类型-vs-白鹅类型" class="headerlink" title="鸭子类型 vs  白鹅类型"></a>鸭子类型 vs  白鹅类型</h3><ul>
<li><strong>鸭子类型</strong>：忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义，这基本上避免了使用<code>isinstance</code>检查对象类型。</li>
<li><strong>白鹅类型</strong>：只要<code>cls</code>是<strong>抽象基类</strong>，即<code>cls</code>的元类是<code>abc.ABCMeta</code>，就可以使用<code>isinstance(obj, cls)</code></li>
</ul>
<h3 id="定义抽象基类的子类"><a href="#定义抽象基类的子类" class="headerlink" title="定义抽象基类的子类"></a>定义抽象基类的子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collections</div><div class="line"></div><div class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck2</span><span class="params">(collections.MutableSequence)</span>:</span></div><div class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</div><div class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</div><div class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self._cards)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._cards[position]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># &lt;1&gt;</span></div><div class="line">        self._cards[position] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, position)</span>:</span>  <span class="comment"># &lt;2&gt;</span></div><div class="line">        <span class="keyword">del</span> self._cards[position]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># &lt;3&gt;</span></div><div class="line">        self._cards.insert(position, value)</div></pre></td></tr></table></figure>
<ol>
<li>为了支持洗牌，只需实现<code>__setitem__</code>方法</li>
<li>但是继承<code>MutableSequence</code>的类必须实现<code>__delitem__</code>方法</li>
<li>此外还必须实现<code>insert</code>方法，如果没有实现那么实例化时会报错</li>
</ol>
<h3 id="标准库中的抽象基类"><a href="#标准库中的抽象基类" class="headerlink" title="标准库中的抽象基类"></a>标准库中的抽象基类</h3><h4 id="collections-abc模块中的抽象基类"><a href="#collections-abc模块中的抽象基类" class="headerlink" title="collections.abc模块中的抽象基类"></a>collections.abc模块中的抽象基类</h4><p><img src="http://oj8vattcf.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB.PNG" alt="抽象基类"></p>
<ul>
<li><p><code>Iterable</code>、<code>Container</code>和<code>Sized</code></p>
<p>各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。<code>Iterable</code>通过<code>__iter__</code>方法支持迭代，<code>Container</code>通过<code>__contains__</code>方法支持<code>in</code>运算符，<code>Sized</code>通过<code>__len__</code>方法支持<code>len()</code>函数</p>
</li>
<li><p><code>Sequence</code>、<code>Mapping</code>和<code>Set</code></p>
<p>这三个是主要的不可变集合类型，而各自都有可变的子类。</p>
</li>
<li><p><code>MappingView</code></p>
<p>映射<code>.items()</code>、<code>.keys()</code>和<code>.values()</code>返回的对象分别是<code>ItemsView</code>、<code>KeyView</code>和<code>ValuesView</code>的实例。前两个类还从<code>Set</code>类继承了丰富的接口</p>
</li>
<li><p><code>Callable</code>和<code>Hashable</code></p>
<p>这两个抽象基类与集合没有太大的关系。这两个抽象基类的主要作用是为内置函数<code>isinstance</code>提供支持，以一种安全的方式判断对象能不能调用或散列</p>
</li>
<li><p><code>Iterator</code></p>
<p>注意它是<code>Iterable</code>的子类</p>
</li>
</ul>
<h4 id="抽象基类的数字塔"><a href="#抽象基类的数字塔" class="headerlink" title="抽象基类的数字塔"></a>抽象基类的数字塔</h4><p><code>numbers</code>包定义的是数字塔，其中<code>Number</code>是位于最顶端的超类，随后是<code>Complex</code>子类，依次往下，最低端是<code>Integral</code>类：</p>
<ul>
<li>Number</li>
<li>Complex</li>
<li>Real</li>
<li>Rational</li>
<li>Integral</li>
</ul>
<h3 id="定义并使用一个抽象基类"><a href="#定义并使用一个抽象基类" class="headerlink" title="定义并使用一个抽象基类"></a>定义并使用一个抽象基类</h3><p>定义一个支持用户提供随机挑选的无重复类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> abc</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># &lt;1&gt;</span></div><div class="line"></div><div class="line"><span class="meta">    @abc.abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span>  <span class="comment"># &lt;2&gt;</span></div><div class="line">        <span class="string">"""Add items from an iterable."""</span></div><div class="line"></div><div class="line"><span class="meta">    @abc.abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span>  <span class="comment"># &lt;3&gt;</span></div><div class="line">        <span class="string">"""Remove item at random, returning it.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        This method should raise `LookupError` when the instance is empty.</span></div><div class="line"><span class="string">        """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># &lt;4&gt;</span></div><div class="line">        <span class="string">"""Return `True` if there's at least 1 item, `False` otherwise."""</span></div><div class="line">        <span class="keyword">return</span> bool(self.inspect())  </div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Return a sorted tuple with the items currently inside."""</span></div><div class="line">        items = []</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                items.append(self.pick())</div><div class="line">            <span class="keyword">except</span> LookupError:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        self.load(items)  </div><div class="line">        <span class="keyword">return</span> tuple(sorted(items))</div></pre></td></tr></table></figure>
<ol>
<li>自己定义的抽象基类要继承<code>abc.ABC</code></li>
<li>抽象方法使用<code>@abstractmethod</code>装饰器标记，而且定义体中通常只有文档字符串</li>
<li>根据文档字符串，如果没有元素可选时，应该抛出<code>LookupError</code></li>
<li>抽象基类中可以包含具体方法，只能使用抽象基类中的其他具体方法、抽象方法或特性</li>
</ol>
<h4 id="抽象基类句法详解"><a href="#抽象基类句法详解" class="headerlink" title="抽象基类句法详解"></a>抽象基类句法详解</h4><ul>
<li>声明抽象基类最简单的方式是继承<code>abc.ABC</code>，旧版中是这样的<code>class Tombola(metaclass=abc.ABCMeta):</code>，更旧版中在类中声明<code>__metaclass__ = abc.ABCMeta</code></li>
<li>在<code>@abstractmethod</code>和<code>def</code>语句之间不能有其他装饰器，也就是说其他装饰器要堆叠在<code>@abstractmethod</code>的上面</li>
</ul>
<h4 id="定义Tombola抽象基类的子类"><a href="#定义Tombola抽象基类的子类" class="headerlink" title="定义Tombola抽象基类的子类"></a>定义Tombola抽象基类的子类</h4><p>开发两个子类，满足<code>Tombola</code>规定的接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span><span class="params">(Tombola)</span>:</span>  <span class="comment"># &lt;1&gt;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></div><div class="line">        self._randomizer = random.SystemRandom()  <span class="comment"># &lt;2&gt;</span></div><div class="line">        self._items = []</div><div class="line">        self.load(items)  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, items)</span>:</span></div><div class="line">        self._items.extend(items)</div><div class="line">        self._randomizer.shuffle(self._items)  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self._items.pop()</div><div class="line">        <span class="keyword">except</span> IndexError:</div><div class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span>  </div><div class="line">        self.pick()</div></pre></td></tr></table></figure>
<ol>
<li>明确指定<code>BingoCage</code>类扩展<code>Tombola</code>类</li>
<li><code>random.SystemRandom</code>使用<code>os.urandom()</code>实现，<code>os.urandom()</code>函数生成适合用于加密的随机字节序列</li>
<li><code>BingoCage</code>从<code>Tombola</code>中继承了耗时的<code>loaded</code>方法和笨拙的<code>inspect</code>方法，并没有覆盖</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryBlower</span><span class="params">(Tombola)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></div><div class="line">        self._balls = list(iterable)  <span class="comment"># 1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></div><div class="line">        self._balls.extend(iterable)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            position = random.randrange(len(self._balls))  </div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</div><div class="line">        <span class="keyword">return</span> self._balls.pop(position)  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 2</span></div><div class="line">        <span class="keyword">return</span> bool(self._balls)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> tuple(sorted(self._balls))</div></pre></td></tr></table></figure>
<ol>
<li>初始化方法接受任何可迭代对象，把参数构建成列表，创建参数的副本，避免原始列表被修改</li>
<li>覆盖<code>loaded</code>方法，避免调用<code>inspect</code>方法，可以直接处理<code>self._balls</code>而不必构建整个有序元组提升速度</li>
</ol>
<h4 id="Tombola的虚拟子类"><a href="#Tombola的虚拟子类" class="headerlink" title="Tombola的虚拟子类"></a>Tombola的虚拟子类</h4><p>白鹅类型的一个基本特性：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。</p>
<p>把<code>Tombolist</code>注册为<code>Tombola</code>的虚拟子类，<code>Tombolist</code>是<code>list</code>的真实子类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</div><div class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</div><div class="line"></div><div class="line"><span class="meta">@Tombola.register  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span>  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self:  </div><div class="line">            position = randrange(len(self))</div><div class="line">            <span class="keyword">return</span> self.pop(position)  </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pop from empty TomboList'</span>)</div><div class="line"></div><div class="line">    load = list.extend  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> bool(self)  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> tuple(sorted(self))</div></pre></td></tr></table></figure>
<h3 id="Tombola子类的测试方法"><a href="#Tombola子类的测试方法" class="headerlink" title="Tombola子类的测试方法"></a>Tombola子类的测试方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> doctest</div><div class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</div><div class="line"></div><div class="line"><span class="keyword">import</span> bingo, lotto, tombolist, drum  <span class="comment"># &lt;1&gt;</span></div><div class="line"></div><div class="line">TEST_FILE = <span class="string">'tombola_tests.rst'</span></div><div class="line">TEST_MSG = <span class="string">'&#123;0:16&#125; &#123;1.attempted:2&#125; tests, &#123;1.failed:2&#125; failed - &#123;2&#125;'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></div><div class="line">    verbose = <span class="string">'-v'</span> <span class="keyword">in</span> argv</div><div class="line">    real_subclasses = Tombola.__subclasses__()  <span class="comment"># &lt;2&gt;</span></div><div class="line">    virtual_subclasses = list(Tombola._abc_registry)  <span class="comment"># &lt;3&gt;</span></div><div class="line">    <span class="keyword">for</span> cls <span class="keyword">in</span> real_subclasses + virtual_subclasses:  </div><div class="line">        test(cls, verbose)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(cls, verbose=False)</span>:</span></div><div class="line">    res = doctest.testfile(</div><div class="line">            TEST_FILE,</div><div class="line">            globs=&#123;<span class="string">'ConcreteTombola'</span>: cls&#125;,  <span class="comment"># &lt;4&gt;</span></div><div class="line">            verbose=verbose,</div><div class="line">            optionflags=doctest.REPORT_ONLY_FIRST_FAILURE)</div><div class="line">    tag = <span class="string">'FAIL'</span> <span class="keyword">if</span> res.failed <span class="keyword">else</span> <span class="string">'OK'</span></div><div class="line">    print(TEST_MSG.format(cls.__name__, res, tag))  </div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">import</span> sys</div><div class="line">    main(sys.argv)</div></pre></td></tr></table></figure>
<ol>
<li>导入包含<code>Tombola</code>真实子类和虚拟子类的模块，用于测试</li>
<li><code>__subclasses__</code>返回类的真实子类列表，不含虚拟子类</li>
<li><code>_abc_registry</code>，只有抽象基类有这个数据属性，其值是一个<code>WeakSet</code>对象，即抽象类注册的虚拟子类的弱引用</li>
<li>把<code>cls</code>参数绑定到全局命名空间里的<code>ConcreteTombola</code>名称上，供<code>doctest</code>使用</li>
</ol>
<h3 id="Python使用register的方式"><a href="#Python使用register的方式" class="headerlink" title="Python使用register的方式"></a>Python使用register的方式</h3><ul>
<li>当作类装饰器使用：<code>@Tombola.register</code></li>
<li>当作普通函数使用：<code>Sequence.register(tuple)</code></li>
</ul>
<h2 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h2><h3 id="子类化内置类型很麻烦"><a href="#子类化内置类型很麻烦" class="headerlink" title="子类化内置类型很麻烦"></a>子类化内置类型很麻烦</h3><p>在Python2.2之后，内置类型可以子类化了。但是使用C语言编写的内置类型不会调用用户定义的类覆盖的特殊方法。如果子类化使用Python编写的类，就不会受此影响。</p>
<ul>
<li>内置类型<code>dict</code>的<code>__init__</code>和<code>__update__</code>方法会忽略我们覆盖的<code>__setitem__</code>方法</li>
<li>子类化<code>collections.UserDict</code>不会覆盖掉</li>
</ul>
<h3 id="多重继承和方法解析顺序"><a href="#多重继承和方法解析顺序" class="headerlink" title="多重继承和方法解析顺序"></a>多重继承和方法解析顺序</h3><p>任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起的。对于同名方法先找到哪个就调用哪个。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'ping:'</span>, self)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'pong:'</span>, self)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'PONG:'</span>, self)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></div><div class="line">        super().ping()   <span class="comment"># 4</span></div><div class="line">        <span class="comment"># A.ping(self)   # 5</span></div><div class="line">        print(<span class="string">'post-ping:'</span>, self)</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></div><div class="line">        self.ping()</div><div class="line">        super().ping()</div><div class="line">        self.pong()</div><div class="line">        super().pong()</div><div class="line">        C.pong(self)</div><div class="line">        </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> diamond <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.pong()   <span class="comment"># 1</span></div><div class="line">pong: &lt;diamond.D object at <span class="number">0x10066c278</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>C.pong(d)   <span class="comment"># 2</span></div><div class="line">PONG: &lt;diamond.D object at <span class="number">0x10066c278</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__   <span class="comment"># 3</span></div><div class="line">(&lt;class 'diamond.D'&gt;, &lt;class 'diamond.B'&gt;, &lt;class 'diamond.C'&gt;,&lt;class 'diamond.A'&gt;, &lt;class 'object'&gt;)</div></pre></td></tr></table></figure>
<ol>
<li>调用<code>d.pong()</code>时运行的是<code>B</code>类中的版本，因为<code>Class D(B, C)</code>中，<code>B</code>在<code>C</code>    前</li>
<li>超类中的方法都可以直接调用，此时把实例作为显式参数传入</li>
<li>Python会按照特定的顺序遍历继承图，这个顺序叫方法解析顺序，类都有一个名为<code>__mro__</code>的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直线上知道<code>object</code>类。</li>
<li>若想把方法调用委托给超类，推荐的方式是使用内置的<code>super()</code>函数</li>
<li>有时可能需要绕过方法解析顺序，直接调用某个超类的方法</li>
</ol>
<h3 id="处理多重继承"><a href="#处理多重继承" class="headerlink" title="处理多重继承"></a>处理多重继承</h3><ol>
<li><p>把<strong>接口继承</strong>和<strong>实现继承</strong>区分开</p>
<ul>
<li>继承接口，创建子类型，实现“是什么”关系，是框架的支柱</li>
<li>继承实现，通过重用避免代码重复，通常可以换用组合和委托模式</li>
</ul>
</li>
<li><p>使用<strong>抽象基类</strong>显式表示接口</p>
<p>现代Python中，如果类的作用是定义接口，应该明确把它定义为抽象基类</p>
</li>
<li><p>通过<strong>混入类</strong>重用代码</p>
<p>如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现是什么的关系，应该把那个类明确的定义为混入类<code>mixinclass</code>。从概念上讲，混入类不定义新类型，只是打包方法便于重用。混入类绝不能实例化，而且具体类不能只继承混入类。混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。</p>
</li>
<li><p>在名称中明确指明混入</p>
<p>因为在Python中没有把类声明为混入的正规方式，所以强烈推荐在名称中假如<code>...Mixin</code>后缀。</p>
</li>
<li><p>抽象基类可以作为混入，反过来则不成立</p>
<p>抽象基类可以实现具体方法，因此也可以作为混入使用。不过，抽象基类会定义类型，而混入做不到。此外，抽象基类可以作为其他类的唯一基类，而混入绝不能作为唯一超类，除非继承另一个更具体的混入。</p>
</li>
<li><p>不要子类化多个<strong>具体类</strong></p>
<p>具体类可以没有或最多只有一个具体超类。也就是说，具体类的超类除了这一个具体超类之外，其余的都是抽象基类或者混入类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConcreteClass</span><span class="params">(Alpha, Beta, Gamma)</span>:</span></div><div class="line">	<span class="string">"""这是一个具体类，可以实例化。"""</span></div><div class="line">	<span class="comment"># ……更多代码</span></div></pre></td></tr></table></figure>
</li>
<li><p>为用户提供<strong>聚合类</strong></p>
<p>如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用易于理解的方式把它们结合起来。这种类称为聚合类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span><span class="params">(BaseWidget, Pack, Place, Grid)</span>:</span></div><div class="line">	<span class="string">"""Internal class.</span></div><div class="line"><span class="string">	</span></div><div class="line"><span class="string">	Base class for a widget which can be positioned with the geometry managers 		</span></div><div class="line"><span class="string">	Pack, Place or Grid."""</span></div><div class="line">	paas</div></pre></td></tr></table></figure>
<p><code>Widget</code>类的定义体是空的，但是这个类提供了有用的服务：把四个超类结合在一起，这样创建新小组件的用户无需记住全部混入，也不用担心声明<code>class</code>语句时没有遵守特定的顺序。</p>
</li>
<li><p>优先使用对象组合，而不是类继承</p>
<p>熟悉继承之后，太容易过渡使用。优先使用组合才能让设计更灵活。因为子类化是一种紧耦合，而且较高的继承树容易倒。<strong>组合和委托</strong>可以代替混入，把行为提供给不同的类，但是不能取代接口继承去定义类型的层次结构。</p>
</li>
<li><p>想想哪些类是真正需要的，我们极少需要编写作为其他类的超类，我们自己编写的类几乎是末端类，当你发现自己在构建多层类层次结构时，你可能在：</p>
<ul>
<li>你在重新发明轮子，去找框架或库，他们提供的组件可以在应用程序中重用</li>
<li>你使用的框架设计不良，去寻找替代品</li>
<li>你在过读设计，记住要遵守<strong>KISS</strong>原则</li>
<li>你厌烦了编写应用程序，决定新造一个框架</li>
</ul>
</li>
</ol>
<h3 id="正确重载运算符"><a href="#正确重载运算符" class="headerlink" title="正确重载运算符"></a>正确重载运算符</h3><h3 id="运算符重载基础"><a href="#运算符重载基础" class="headerlink" title="运算符重载基础"></a>运算符重载基础</h3><ul>
<li>不能重载内置类型的运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>某些运算符不能重载，<code>is</code>、<code>and</code>、<code>or</code>和<code>not</code>不能，<code>&amp;</code>、<code>|</code>和<code>~</code>可以</li>
</ul>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>支持一元运算符很简单，只需实现相应的特殊方法。这些特殊方法只有一个参数，<code>self</code>。然后使用符合所在类的逻辑实现，始终返回一个新对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)  <span class="comment"># &lt;1&gt;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> Vector(self)  <span class="comment"># &lt;2&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>为了计算<code>-v</code>，构建一个新的<code>Vector</code>实例，把<code>self</code>的每个分量都取反</li>
<li>为了计算<code>+v</code>，构建一个新的<code>Vector</code>实例，传入<code>self</code>的各个分量</li>
</ol>
<h3 id="重载向量加法运算符"><a href="#重载向量加法运算符" class="headerlink" title="重载向量加法运算符+"></a>重载向量加法运算符+</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)  <span class="comment"># 1</span></div><div class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</div><div class="line">    <span class="keyword">except</span> TypeError:     </div><div class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>   <span class="comment"># 2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span>   <span class="comment"># 3</span></div><div class="line">    <span class="keyword">return</span> self + other</div></pre></td></tr></table></figure>
<ol>
<li><code>pairs</code>是个生成器，它会生成<code>(a, b)</code>形式的元组，其中<code>a</code>来自<code>self</code>，<code>b</code>来自<code>other</code>。如果<code>self</code>和<code>other</code>的长度不同，使用<code>fillvalue</code>填充较短那个可迭代对象</li>
<li>如果由于类型不兼容而导致运算符特殊方法无法返回有效的结果，那么应该返回<code>NotImplemented</code>，而不是抛出<code>TpyeError</code>。返回<code>NotImplemented</code>时，另一个操作数所属的类型的<strong>还有机会</strong>执行运算，而Python会尝试调用反向方法。</li>
<li>如果左操作数没有实现<code>__add__</code>方法或者实现了但是返回<code>NotImplemented</code>表明它不知道如何处理右操作数，那么Python会调用<code>__radd__</code>方法</li>
<li><code>__radd__</code>直接委托<code>__add__</code></li>
</ol>
<h3 id="重载标量乘法运算符"><a href="#重载标量乘法运算符" class="headerlink" title="重载标量乘法运算符*"></a>重载标量乘法运算符*</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(scalar, numbers.Real):   <span class="comment"># 1</span></div><div class="line">        <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></div><div class="line">    <span class="keyword">return</span> self * scalar</div></pre></td></tr></table></figure>
<ol>
<li>如果<code>scalar</code>是<code>numbers.Real</code>某个子类的实例，用分量的乘积创建一个新的<code>Vector</code>实例</li>
<li>否则，返回<code>NotImplemented</code>，让Python尝试在<code>scalar</code>操作数上调用<code>__rmul__</code>方法</li>
<li><code>__rmul__</code>直接委托<code>__mul__</code></li>
</ol>
<h3 id="众多比较运算符"><a href="#众多比较运算符" class="headerlink" title="众多比较运算符"></a>众多比较运算符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(other, Vector):  <span class="comment"># &lt;1&gt;</span></div><div class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></div><div class="line">                all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># &lt;2&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>如果<code>other</code>操作数是<code>Vector</code>实例，那就像之前那样比较</li>
<li>否则，返回<code>NotImplemnted</code></li>
</ol>
<h3 id="增量赋值运算符"><a href="#增量赋值运算符" class="headerlink" title="增量赋值运算符"></a>增量赋值运算符</h3><p>增量赋值不会修改不可变目标，而是新建实例，然后重新绑定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableBingoCage</span><span class="params">(BingoCage)</span>:</span>  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(other, Tombola): </div><div class="line">            <span class="keyword">return</span> AddableBingoCage(self.inspect() + other.inspect())  </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(other, Tombola):</div><div class="line">            other_iterable = other.inspect()  <span class="comment"># 1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                other_iterable = iter(other)  <span class="comment"># 2</span></div><div class="line">            <span class="keyword">except</span> TypeError:  </div><div class="line">                self_cls = type(self).__name__</div><div class="line">                msg = <span class="string">"right operand in += must be &#123;!r&#125; or an iterable"</span></div><div class="line">                <span class="keyword">raise</span> TypeError(msg.format(self_cls))</div><div class="line">        self.load(other_iterable)  </div><div class="line">        <span class="keyword">return</span> self  <span class="comment"># 3</span></div></pre></td></tr></table></figure>
<ol>
<li>如果<code>other</code>是<code>Tombola</code>实例，从中获取元素，否则尝试使用<code>other</code>创建迭代器</li>
<li>如果尝试失败，抛出异常，并告知用户该怎么做。如果可能，错误消息应该明确指导用户怎么解决问题</li>
<li>增量赋值特殊方法必须返回<code>self</code></li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-03-23T02:14:29.000Z" itemprop="dateUpdated">2018-03-23 10:14:29</time>
</span><br>


        
    </div>
    <footer>
        <a href="http://printxhl.com">
            <img src="/img/avatar.jpg" alt="谢海练">
            谢海练
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/05/30/Python-Django-Architecture/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Django 工程结构</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/05/30/Python-Django-Deploy/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Django 部署</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <!-- <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>footer.license</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>谢海练 &copy; 2017 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer> -->

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.6.13"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.13" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>








</body>
</html>
