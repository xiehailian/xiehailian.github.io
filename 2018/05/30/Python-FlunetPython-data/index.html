<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Fluent Python (1)：数据结构 | PrintXHL | 我就想做一点微小的工作</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#2361b6">
    
    
    <meta name="keywords" content="Python">
    <meta name="description" content="数据模型纸牌的数据模型1234567891011121314151617181920import collectionsCard = collections.namedtuple(&apos;Card&apos;, [&apos;rank&apos;, &apos;suit&apos;]) # 1class FrenchDeck:    ranks = [str(n) for n in range(2, 11)] + list(&apos;JQKA&apos;) # 2">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Fluent Python (1)：数据结构">
<meta property="og:url" content="http://printxhl.com/2018/05/30/Python-FlunetPython-data/index.html">
<meta property="og:site_name" content="PrintXHL">
<meta property="og:description" content="数据模型纸牌的数据模型1234567891011121314151617181920import collectionsCard = collections.namedtuple(&apos;Card&apos;, [&apos;rank&apos;, &apos;suit&apos;]) # 1class FrenchDeck:    ranks = [str(n) for n in range(2, 11)] + list(&apos;JQKA&apos;) # 2">
<meta property="og:image" content="http://oj8vattcf.bkt.clouddn.com/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95.png">
<meta property="og:updated_time" content="2018-03-04T08:52:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fluent Python (1)：数据结构">
<meta name="twitter:description" content="数据模型纸牌的数据模型1234567891011121314151617181920import collectionsCard = collections.namedtuple(&apos;Card&apos;, [&apos;rank&apos;, &apos;suit&apos;]) # 1class FrenchDeck:    ranks = [str(n) for n in range(2, 11)] + list(&apos;JQKA&apos;) # 2">
<meta name="twitter:image" content="http://oj8vattcf.bkt.clouddn.com/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95.png">
    
        <link rel="alternate" type="application/atom+xml" title="PrintXHL" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.13">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">谢海练</h5>
          <a href="mailto:xiehailian66@126.com" title="xiehailian66@126.com" class="mail">xiehailian66@126.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/python"  >
                <i class="icon icon-lg icon-code"></i>
                Python
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/data"  >
                <i class="icon icon-lg icon-database"></i>
                Data
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/book"  >
                <i class="icon icon-lg icon-book"></i>
                Book
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/xiehailian" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Fluent Python (1)：数据结构</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Fluent Python (1)：数据结构</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-05-30T06:55:00.392Z" itemprop="datePublished" class="page-time">
  2018-05-30
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据模型"><span class="post-toc-number">1.</span> <span class="post-toc-text">数据模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#纸牌的数据模型"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">纸牌的数据模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#向量的数据模型"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">向量的数据模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列构成的数组"><span class="post-toc-number">2.</span> <span class="post-toc-text">序列构成的数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内置序列类型概览"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">内置序列类型概览</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列表推导和生成器表达式"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">列表推导和生成器表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#列表解析式"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">列表解析式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#生成器表达式"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">生成器表达式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元组"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">元组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#元组和记录"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">元组和记录</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#元组拆包"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">元组拆包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#具名元组"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">具名元组</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">切片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-和-拼接序列"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">使用+和*拼接序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#序列的增量赋值"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">序列的增量赋值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-sort方法和内置函数sorted"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">list.sort方法和内置函数sorted</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用bisect来管理已排序的序列"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">用bisect来管理已排序的序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#用bisect来搜索"><span class="post-toc-number">2.8.1.</span> <span class="post-toc-text">用bisect来搜索</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#用bisect-insort插入新元素"><span class="post-toc-number">2.8.2.</span> <span class="post-toc-text">用bisect.insort插入新元素</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#当列表不是首选时"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">当列表不是首选时</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组"><span class="post-toc-number">2.9.1.</span> <span class="post-toc-text">数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内存视图"><span class="post-toc-number">2.9.2.</span> <span class="post-toc-text">内存视图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#NumPy和SciPy"><span class="post-toc-number">2.9.3.</span> <span class="post-toc-text">NumPy和SciPy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#队列"><span class="post-toc-number">2.9.4.</span> <span class="post-toc-text">队列</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字典和集合"><span class="post-toc-number">3.</span> <span class="post-toc-text">字典和集合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#泛映射类型"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">泛映射类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典推导"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">字典推导</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常见映射方法"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">常见映射方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#update"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">update</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#setdefault"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">setdefault</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#映射的弹性键查询"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">映射的弹性键查询</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#defaultdict"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">defaultdict</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#missing"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">__missing__</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典的变种"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">字典的变种</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#collections-OrderedDict"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">collections.OrderedDict</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#collections-ChainMap"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">collections.ChainMap</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#collections-Counter"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">collections.Counter</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#collections-UserDict"><span class="post-toc-number">3.5.4.</span> <span class="post-toc-text">collections.UserDict</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#子类化UserDict"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">子类化UserDict</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不可变映射类型"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">不可变映射类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#集合论"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">集合论</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dict和set的背后"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">dict和set的背后</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#dict和set的效率"><span class="post-toc-number">3.9.1.</span> <span class="post-toc-text">dict和set的效率</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#字典中的散列表"><span class="post-toc-number">3.9.2.</span> <span class="post-toc-text">字典中的散列表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#dict的实现及其导致的结果"><span class="post-toc-number">3.9.3.</span> <span class="post-toc-text">dict的实现及其导致的结果</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#set的实现以及导致的结果"><span class="post-toc-number">3.9.4.</span> <span class="post-toc-text">set的实现以及导致的结果</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文本和字节序列"><span class="post-toc-number">4.</span> <span class="post-toc-text">文本和字节序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符问题"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">字符问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字节概要"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">字节概要</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基本的编解码器"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">基本的编解码器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#了解编解码问题"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">了解编解码问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#处理UnicodeEncodeError"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">处理UnicodeEncodeError</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#处理UnicodeDecodeError"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">处理UnicodeDecodeError</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用预期之外的编码加载模块时抛出的SyntaxError"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">使用预期之外的编码加载模块时抛出的SyntaxError</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何找出字节序列的编码"><span class="post-toc-number">4.4.4.</span> <span class="post-toc-text">如何找出字节序列的编码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BOM-有用的鬼符"><span class="post-toc-number">4.4.5.</span> <span class="post-toc-text">BOM: 有用的鬼符</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#处理文本文件"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">处理文本文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#编码默认值：一团糟"><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">编码默认值：一团糟</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为了正确比较而规范化Unicode字符串"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">为了正确比较而规范化Unicode字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#大小写折叠"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">大小写折叠</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#规范化文本匹配实用函数"><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">规范化文本匹配实用函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#极端规范化：去掉变音符号"><span class="post-toc-number">4.6.3.</span> <span class="post-toc-text">极端规范化：去掉变音符号</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Unicode文本排序"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">Unicode文本排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Unicode数据库"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">Unicode数据库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#支持字符串和字节序列的双模式API"><span class="post-toc-number">4.9.</span> <span class="post-toc-text">支持字符串和字节序列的双模式API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#正则表达式中的字符串和字节序列"><span class="post-toc-number">4.9.1.</span> <span class="post-toc-text">正则表达式中的字符串和字节序列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#os函数中的字符串和字节序列"><span class="post-toc-number">4.9.2.</span> <span class="post-toc-text">os函数中的字符串和字节序列</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-Python-FlunetPython-data"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Fluent Python (1)：数据结构</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-05-30 14:55:00" datetime="2018-05-30T06:55:00.392Z"  itemprop="datePublished">2018-05-30</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="纸牌的数据模型"><a href="#纸牌的数据模型" class="headerlink" title="纸牌的数据模型"></a>纸牌的数据模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collections</div><div class="line"></div><div class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>]) <span class="comment"># 1</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></div><div class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>) <span class="comment"># 2</span></div><div class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  <span class="comment"># 3</span></div><div class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits  <span class="comment"># 4</span></div><div class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span>	<span class="comment"># 5</span></div><div class="line">        <span class="keyword">return</span> len(self._cards)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span>  <span class="comment"># 6</span></div><div class="line">        <span class="keyword">return</span> self._cards[position]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    deck = FrenchDeck()</div></pre></td></tr></table></figure>
<ol>
<li><code>collections.namedtuple</code>：用以构建只有少数属性但是没有方法的对象，如数据库条目</li>
<li>类属型，类和实例皆可访问</li>
<li><code>__init__</code>：创建实例时的初始化</li>
<li>实例属性<ul>
<li><code>self.cards</code>：公共属性，在类和子类中使用，实例化后可以访问</li>
<li><code>self._cards</code>：单下划线，表示私有（保护类型）类型（方法，属性），在类和子类中使用，假装不给实例化后访问</li>
<li><code>self.__cards</code>：双下划线，表示私有类型，子类不可访问，硬要访问的话<code>_FrenchDeck__cards</code></li>
</ul>
</li>
<li><code>__len__</code>：特殊方法，<code>len(deck) == deck.__len__()</code></li>
<li><code>__getitem__</code>：特殊方法，<code>deck[1] == deck__getitem__(1)</code></li>
</ol>
<h3 id="向量的数据模型"><a href="#向量的数据模型" class="headerlink" title="向量的数据模型"></a>向量的数据模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># 1</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)  <span class="comment"># 2</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span>  <span class="comment"># 3</span></div><div class="line">        <span class="keyword">return</span> bool(abs(self))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 4</span></div><div class="line">        x = self.x + other.x</div><div class="line">        y = self.y + other.y</div><div class="line">        <span class="keyword">return</span> Vector(x, y)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    a = Vector(<span class="number">4</span>, <span class="number">9</span>)</div><div class="line">    b = Vector(<span class="number">4</span>, <span class="number">6</span>)</div><div class="line">    print(a+b)</div></pre></td></tr></table></figure>
<ol>
<li><code>__repr__</code>  vs <code>__str__</code><ul>
<li><code>__repr__</code>：字符串表示形式，所返回的字符串准确无歧义，打印一个对象时用特定字符串显示，如果没有实现这个方法，打印时得到的字符串可能是<code>&lt;Vector object at 0x10e100070&gt;</code></li>
<li><code>__str__</code>：使用<code>str()</code>函数或<code>print</code>函数时被调用，如果对象没有这个方法，解释器会用<code>__repr__</code>代替，所以优先定义<code>__repr__</code>方法</li>
</ul>
</li>
<li><code>%r</code> vs <code>%s</code><ul>
<li><code>%r</code>：使用<code>repr()</code>函数格式化对象</li>
<li><code>%s</code>：使用<code>str()</code>函数格式化对象</li>
<li><code>&quot;i love %s&quot;%&#39;you&#39; != &quot;i love %r&quot;%&#39;you&#39;</code></li>
</ul>
</li>
<li><code>__bool__</code>：自定义布尔值，<code>if Vector(0,0)</code> &lt;=&gt; <code>if Vector(0,0)__bool__()</code></li>
<li><code>__add__</code>, <code>__mul__</code>：自定义加法，自定义乘法</li>
</ol>
<h2 id="序列构成的数组"><a href="#序列构成的数组" class="headerlink" title="序列构成的数组"></a>序列构成的数组</h2><h3 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h3><p>序列，故名思义，有顺序的一组数据。序列无非就是：迭代、切片、排序、拼接</p>
<ul>
<li>按存放的数据类型分类<ul>
<li>容器序列(可存放不同类型的数据)：<code>list</code>、<code>tuple</code>、<code>collections.deque</code></li>
<li>扁平序列(只能存放一种类型)：<code>str</code>、<code>bytes</code>、<code>bytearray</code>、<code>memeryview</code>、<code>array.array</code></li>
</ul>
</li>
<li>按能否被修改来分类<ul>
<li>可变序列：<code>list</code>、<code>bytearray</code>、<code>array.array</code>、<code>collections.deque</code>、<code>memeryview</code></li>
<li>不可变序列：<code>tuple</code>、<code>str</code>、<code>bytes</code></li>
</ul>
</li>
</ul>
<h3 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h3><h4 id="列表解析式"><a href="#列表解析式" class="headerlink" title="列表解析式"></a>列表解析式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">symbols = <span class="string">'$¢£¥€¤'</span></div><div class="line">codes = [ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbol] <span class="comment"># 1</span></div><div class="line"></div><div class="line">symbols = <span class="string">'$¢£¥€¤'</span></div><div class="line">beyond_ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s) &gt; <span class="number">127</span>]</div><div class="line">beyond_ascii = list(filter(<span class="keyword">lambda</span> c: c &gt; <span class="number">127</span>, map(ord, symbols)  <span class="comment"># 2</span></div><div class="line">                           </div><div class="line">colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</div><div class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</div><div class="line">tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes] <span class="comment"># 3</span></div><div class="line">tshirts = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors]</div></pre></td></tr></table></figure>
<ol>
<li>列表解析式的可读性好，太复杂时也不要滥用</li>
<li><code>filter</code>和<code>map</code>合起来能做的事，列表解析式也能做，而且可读性更好</li>
<li>列表解析式可以生成两个或两个以上的可迭代类型的笛卡尔积</li>
</ol>
<h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">symbols = <span class="string">'$¢£¥€¤'</span></div><div class="line">tuple(ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)  <span class="comment"># 1</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> array</div><div class="line">array.array(<span class="string">'I'</span>, (ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))  <span class="comment"># 2 </span></div><div class="line"></div><div class="line">colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</div><div class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</div><div class="line"><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">'%s %s'</span>%(c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes):  <span class="comment"># 3</span></div><div class="line">    print(tshirt)</div></pre></td></tr></table></figure>
<ol>
<li>如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要用括号围起来</li>
<li><code>array</code>的构造方法需要两个参数，括号是必须的</li>
<li>生成器表达式会逐个产出元素，避免额外的内存占用</li>
</ol>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><h4 id="元组和记录"><a href="#元组和记录" class="headerlink" title="元组和记录"></a>元组和记录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">traveler_ids = [(<span class="string">'USA'</span>, <span class="string">'31195855'</span>), (<span class="string">'BRA'</span>, <span class="string">'CE342567'</span>), (<span class="string">'ESP'</span>, <span class="string">'XDA205856'</span>)]</div><div class="line"><span class="keyword">for</span> passport <span class="keyword">in</span> sorted(traveler_ids):  </div><div class="line">	print(<span class="string">'%s/%s'</span> % passport)  <span class="comment"># 1</span></div><div class="line">    </div><div class="line"><span class="keyword">for</span> contry, _ <span class="keyword">in</span> traveler_id:  <span class="comment"># 2</span></div><div class="line">    print(country)</div></pre></td></tr></table></figure>
<ol>
<li><code>%</code>格式化运算符能被匹配到对应的元组元素上</li>
<li><code>for</code>循环可以分别提取元组的元素，也作拆包，因为第二个元素对我们没什么用，所以赋值给占位符<code>_</code></li>
</ol>
<h4 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b, a = a, b  <span class="comment"># 1</span></div><div class="line"></div><div class="line">t = (<span class="number">20</span>, <span class="number">8</span>)  <span class="comment"># 2</span></div><div class="line">divmod(*t)</div><div class="line"></div><div class="line">a, *body, c, d = range(<span class="number">5</span>)  <span class="comment">#3</span></div></pre></td></tr></table></figure>
<ol>
<li>优雅的不用中间变量交换两个变量的值</li>
<li><code>*</code>运算符把一个可迭代对象拆开作为函数的参数</li>
<li>用<code>*</code>来处理剩下的元素</li>
</ol>
<h4 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line">City = namedtuple(<span class="string">'City'</span>, <span class="string">'name country population coordinates'</span>)   <span class="comment"># 1</span></div><div class="line">tokyo = City(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))   <span class="comment"># 2</span></div><div class="line"></div><div class="line">City._fields   <span class="comment"># 3</span></div><div class="line">delhi_data = (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))  </div><div class="line">delhi = City._make(delhi_data)  <span class="comment"># 4</span></div><div class="line">delhi._asdict()  <span class="comment"># 5</span></div></pre></td></tr></table></figure>
<ol>
<li>创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字，后者形式可以是<code>&#39;name country population coordinates&#39;</code>或者是<code>[&#39;name&#39;, &#39;counry&#39;, &#39;population&#39;, &#39;coordinates&#39;]</code></li>
<li>存放在对应字段的数据要以一串参数的形式传入到构造函数中</li>
<li><code>_fields</code>属性是一个包含这个类所有字段名称的元组</li>
<li><code>City._make(delhi_data) == City(*delhi_data)</code></li>
<li><code>_asdict()</code>把具名元组以<code>collections.OrderedDict</code>的形式返回，把元组里的信息友好的呈现出来</li>
</ol>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">'bicycle'</span>  <span class="comment"># 1</span></div><div class="line">s[::<span class="number">3</span>]</div><div class="line">s[::<span class="number">-1</span>]</div><div class="line">s[::<span class="number">-2</span>]</div><div class="line">s[<span class="number">2</span>::<span class="number">3</span>]</div><div class="line"></div><div class="line">l = list(range(<span class="number">10</span>))  <span class="comment"># 2</span></div><div class="line">l[<span class="number">2</span>::<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</div><div class="line"><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</div><div class="line">l[<span class="number">3</span>::<span class="number">2</span>] =[<span class="number">11</span>, <span class="number">22</span>]</div><div class="line">l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>]</div></pre></td></tr></table></figure>
<ol>
<li><code>seq[start:stop:step]</code>，<code>start</code>无值时从头开始，<code>stop</code>无值时至尾结束，<code>step</code>为负时反向取值</li>
<li>如果赋值对象是一个切片，那么赋值语句的右侧必须是可迭代对象，即使只有一个单独的值，也要转换为可迭代序列</li>
</ol>
<h3 id="使用-和-拼接序列"><a href="#使用-和-拼接序列" class="headerlink" title="使用+和*拼接序列"></a>使用+和*拼接序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">l = [1, 2, 3]  # 1</div><div class="line">l * 5</div><div class="line">5 * &apos;abcd&apos;</div><div class="line"></div><div class="line">board = [[&apos;_&apos;] * 3 for i in range(3)]  # 2</div><div class="line">board[1][2] = &apos;X&apos;</div><div class="line">wrong_board = [[&apos;_&apos;] *3] * 3</div><div class="line">wrong_board[1][2] = &apos;X&apos;</div></pre></td></tr></table></figure>
<ol>
<li>Python程序员会默认序列是支持<code>+</code>和<code>*</code>操作的</li>
<li><code>board != wrong_board</code>，引用传递和值传递的不同，可变对象都是引用传递，原地址没变</li>
</ol>
<h3 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</div><div class="line">Traceback (most recent call last):File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>])</div></pre></td></tr></table></figure>
<ol>
<li>不要把可变对象放在元祖里</li>
<li>增量赋值不是一个原子操作，虽然抛出了异常，但是还是完成了操作</li>
<li>通过<code>dis.dis(&#39;t[2] += [50, 60]&#39;)</code>可以查看Python的字节码，帮助我们了解代码背后的运行机制</li>
</ol>
<h3 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fruits = [<span class="string">'grape'</span>, <span class="string">'raspberry'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>]</div><div class="line">sorted(fruits)</div><div class="line">sorted(fruits, key=len, reverse=<span class="keyword">True</span>)  <span class="comment"># 1</span></div><div class="line">fruits.sort()  <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<ol>
<li>新建一个按长度降序排序的结果</li>
<li>对原列表就地排序，返回值为<code>None</code>会被控制台忽略</li>
</ol>
<h3 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h3><h4 id="用bisect来搜索"><a href="#用bisect来搜索" class="headerlink" title="用bisect来搜索"></a>用bisect来搜索</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bisect</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">HAYSTACK = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">29</span>, <span class="number">30</span>]</div><div class="line">NEEDLES = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]</div><div class="line"></div><div class="line">ROW_FMT = <span class="string">'&#123;0:2d&#125; @ &#123;1:2d&#125;    &#123;2&#125;&#123;0:&lt;2d&#125;'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(bisect_fn)</span>:</span></div><div class="line">    <span class="keyword">for</span> needle <span class="keyword">in</span> reversed(NEEDLES):</div><div class="line">        position = bisect_fn(HAYSTACK, needle)  <span class="comment"># &lt;1&gt;</span></div><div class="line">        <span class="comment"># print (position)</span></div><div class="line">        offset = position * <span class="string">'  |'</span>  <span class="comment"># &lt;2&gt;</span></div><div class="line">        print(ROW_FMT.format(needle, position, offset))  <span class="comment"># &lt;3&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    <span class="keyword">if</span> sys.argv[<span class="number">-1</span>] == <span class="string">'left'</span>:    <span class="comment"># &lt;4&gt;</span></div><div class="line">        bisect_fn = bisect.bisect_left</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        bisect_fn = bisect.bisect</div><div class="line"></div><div class="line">    print(<span class="string">'DEMO:'</span>, bisect_fn.__name__)  <span class="comment"># &lt;5&gt;</span></div><div class="line">    print(<span class="string">'haystack -&gt;'</span>, <span class="string">' '</span>.join(<span class="string">'%2d'</span> % n <span class="keyword">for</span> n <span class="keyword">in</span> HAYSTACK))</div><div class="line">    demo(bisect_fn)</div></pre></td></tr></table></figure>
<h4 id="用bisect-insort插入新元素"><a href="#用bisect-insort插入新元素" class="headerlink" title="用bisect.insort插入新元素"></a>用bisect.insort插入新元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bisect</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">SIZE = <span class="number">7</span></div><div class="line"></div><div class="line">random.seed(<span class="number">1729</span>)</div><div class="line"></div><div class="line">my_list = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(SIZE):</div><div class="line">    new_item = random.randrange(SIZE*<span class="number">2</span>)</div><div class="line">    bisect.insort(my_list, new_item)</div><div class="line">    print(<span class="string">'%2d -&gt;'</span> % new_item, my_list)</div></pre></td></tr></table></figure>
<h3 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</div><div class="line">floats = array(<span class="string">'d'</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">7</span>)))  <span class="comment"># 1</span></div><div class="line"></div><div class="line">fp = open(<span class="string">'floats.bin'</span>, <span class="string">'wb'</span>)</div><div class="line">floats.tofile(fp)  <span class="comment"># 2</span></div><div class="line">fp.close()</div><div class="line">fp = open(<span class="string">'floats.bin'</span>, <span class="string">'rb'</span>)</div><div class="line">floats.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)  <span class="comment"># 3</span></div><div class="line">fp.close()</div></pre></td></tr></table></figure>
<ol>
<li>利用一个可迭代对象建立一个双精度浮点数组，类型码是<code>d</code>，如果我们只需要一个包含数字的列表，那么<code>array.array</code>比<code>list</code>更高效</li>
<li><code>array.tofile</code>把数组存入文件，比写入文本文件快7倍</li>
<li><code>array.fromfile</code>把数组从文件读取出来，比从文本文件读取出来快60倍</li>
</ol>
<h4 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h4><h4 id="NumPy和SciPy"><a href="#NumPy和SciPy" class="headerlink" title="NumPy和SciPy"></a>NumPy和SciPy</h4><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h2 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h2><h3 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my_dict = &#123;&#125;</div><div class="line">isinstance(my_dict, abc.Mapping)  <span class="comment"># 1</span></div><div class="line"></div><div class="line">tl = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</div><div class="line">hash(tl)  <span class="comment"># 2</span></div><div class="line"></div><div class="line">a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)  <span class="comment"># 3</span></div><div class="line">b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</div><div class="line">c = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</div><div class="line">d = dict([(<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])</div><div class="line">e = dict(&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;)</div></pre></td></tr></table></figure>
<ol>
<li><code>collections.adc</code>模块中有<code>Mapping</code>和<code>MutableMapping</code>这两个抽象基类，为<code>dict</code>和其他类似的类型定义形式接口</li>
<li>不可变对象都是可散列对象，就是说可变对象不能作为字典的键，如果元组中有可变对象就例外</li>
<li><code>a == b == c == d == e</code></li>
</ol>
<h3 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">DIAL_CODES = [</div><div class="line">        (<span class="number">86</span>, <span class="string">'China'</span>),</div><div class="line">        (<span class="number">91</span>, <span class="string">'India'</span>),</div><div class="line">        (<span class="number">1</span>, <span class="string">'United States'</span>),</div><div class="line">        (<span class="number">62</span>, <span class="string">'Indonesia'</span>),</div><div class="line">        (<span class="number">55</span>, <span class="string">'Brazil'</span>),</div><div class="line">        (<span class="number">92</span>, <span class="string">'Pakistan'</span>),</div><div class="line">        (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</div><div class="line">        (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</div><div class="line">        (<span class="number">7</span>, <span class="string">'Russia'</span>),</div><div class="line">        (<span class="number">81</span>, <span class="string">'Japan'</span>),</div><div class="line">    ]</div><div class="line"></div><div class="line">country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</div><div class="line">&#123;code: country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_code.items() <span class="keyword">if</span> code &lt; <span class="number">66</span>&#125;</div></pre></td></tr></table></figure>
<h3 id="常见映射方法"><a href="#常见映射方法" class="headerlink" title="常见映射方法"></a>常见映射方法</h3><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;&#125;</div><div class="line">m = &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;  </div><div class="line">a.update(m)  <span class="comment"># 1</span></div><div class="line">m = &#123;<span class="string">'b'</span>: <span class="number">3</span>&#125;</div><div class="line">a.update(**m)  <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<ol>
<li>没则插入</li>
<li>有则更新</li>
</ol>
<h4 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault"></a>setdefault</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">WORD_RE = re.compile(<span class="string">'\w+'</span>)</div><div class="line"></div><div class="line">index = &#123;&#125;</div><div class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fp:</div><div class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> enumerate(fp, <span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</div><div class="line">            word = match.group()</div><div class="line">            column_no = match.start()+<span class="number">1</span></div><div class="line">            location = (line_no, column_no)</div><div class="line">            index.setdefault(word, []).append(location)  <span class="comment"># 1</span></div><div class="line"></div><div class="line"><span class="comment"># print in alphabetical order</span></div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sorted(index, key=str.upper):</div><div class="line">    print(word, index[word])</div></pre></td></tr></table></figure>
<ol>
<li>获取单词出现情况的列表。如果单词不存在，单词做键，空列表做值放进字典；如果单词存在，把值添加到单词对用的列表</li>
</ol>
<h3 id="映射的弹性键查询"><a href="#映射的弹性键查询" class="headerlink" title="映射的弹性键查询"></a>映射的弹性键查询</h3><h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> collections</div><div class="line"></div><div class="line">WORD_RE = re.compile(<span class="string">'\w+'</span>)</div><div class="line"></div><div class="line">index = collections.defaultdict(list)     <span class="comment"># 1</span></div><div class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fp:</div><div class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> enumerate(fp, <span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</div><div class="line">            word = match.group()</div><div class="line">            column_no = match.start()+<span class="number">1</span></div><div class="line">            location = (line_no, column_no)</div><div class="line">            index[word].append(location)  <span class="comment"># 2</span></div><div class="line"></div><div class="line"><span class="comment"># print in alphabetical order</span></div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sorted(index, key=str.upper):</div><div class="line">    print(word, index[word])</div></pre></td></tr></table></figure>
<ol>
<li>把<code>list</code>构造方法作为<code>default_factory</code>来构建一个<code>defaultdict</code></li>
<li>如果index并没有word的记录，那么<code>default_factory</code>会被调用，为查询不到的键创造一个值，这个值在这里是空列表</li>
</ol>
<h4 id="missing"><a href="#missing" class="headerlink" title="__missing__"></a><code>__missing__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span><span class="params">(dict)</span>:</span>  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span>  <span class="comment"># 1</span></div><div class="line">        <span class="keyword">if</span> isinstance(key, str):  </div><div class="line">            <span class="keyword">raise</span> KeyError(key)</div><div class="line">        <span class="keyword">return</span> self[str(key)]  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self[key]  </div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">return</span> default  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span>  <span class="comment"># 2</span></div><div class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()</div></pre></td></tr></table></figure>
<ol>
<li><code>__missing__</code>在映射类型找不到键时调用，通过<code>isinstance(key, str)</code>测试，避免代码陷入无限递归</li>
<li><code>dict.__contains__(key) == key in dict</code>，直接在<code>self.keys()</code>里查询，避免递归调用</li>
</ol>
<h3 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h3><h4 id="collections-OrderedDict"><a href="#collections-OrderedDict" class="headerlink" title="collections.OrderedDict"></a>collections.OrderedDict</h4><h4 id="collections-ChainMap"><a href="#collections-ChainMap" class="headerlink" title="collections.ChainMap"></a>collections.ChainMap</h4><h4 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h4><h4 id="collections-UserDict"><a href="#collections-UserDict" class="headerlink" title="collections.UserDict"></a>collections.UserDict</h4><h3 id="子类化UserDict"><a href="#子类化UserDict" class="headerlink" title="子类化UserDict"></a>子类化UserDict</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collections</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(collections.UserDict)</span>:</span>  <span class="comment"># 1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span> </div><div class="line">        <span class="keyword">if</span> isinstance(key, str):</div><div class="line">            <span class="keyword">raise</span> KeyError(key)</div><div class="line">        <span class="keyword">return</span> self[str(key)]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> str(key) <span class="keyword">in</span> self.data  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, item)</span>:</span></div><div class="line">        self.data[str(key)] = item   <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<ol>
<li>更倾向于从<code>UserDict</code>而不是<code>dict</code>的子类继承的主要原因是，后者会在某些方法的实现上走一些捷径，导致在子类中不得不重写这些方法</li>
<li><code>__setitem__</code>会把所有的键都转换成字符串</li>
</ol>
<h3 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">'A'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxymappingproxy(&#123;<span class="number">1</span>: <span class="string">'A'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>] </div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">'x'</span></div><div class="line">Traceback (most recent call last):File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: <span class="string">'mappingproxy'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">'B'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy </div><div class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</div><div class="line"><span class="string">'B'</span></div></pre></td></tr></table></figure>
<h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">l = [<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>]</div><div class="line">set(l)  <span class="comment"># 1</span></div><div class="line"></div><div class="line">found = len(needles &amp; haystack)  <span class="comment"># 2</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</div><div class="line">&#123;chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">'SIGN'</span> <span class="keyword">in</span> name(chr(i), <span class="string">''</span>)&#125;  <span class="comment"># 3</span></div></pre></td></tr></table></figure>
<ol>
<li>集合去重</li>
<li>集合运算</li>
<li>集合解析式</li>
</ol>
<h3 id="dict和set的背后"><a href="#dict和set的背后" class="headerlink" title="dict和set的背后"></a>dict和set的背后</h3><h4 id="dict和set的效率"><a href="#dict和set的效率" class="headerlink" title="dict和set的效率"></a>dict和set的效率</h4><p>不管查询有多少个元素的字典和集合，所耗费的时间都能忽略不计。而列表随元素的增多，查询时间越长。</p>
<h4 id="字典中的散列表"><a href="#字典中的散列表" class="headerlink" title="字典中的散列表"></a>字典中的散列表</h4><ol>
<li><p>散列表</p>
<p>Python用散列表来实现dict类型，散列表其实是一个稀疏数组，总有空白元素的数组成为稀疏数组。散列表的结构单元被称为<strong>表元</strong>，在dict的散列表中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，一个是对值的应用，因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。因为Python会设法保证大概有三分之一的表元是空的，所以在快要达到这个阈值时，原有散列表会被复制到一个更大的空间。</p>
</li>
<li><p>散列值和相等性</p>
<p>如果两个对象在比较的时候相等，那么它们的散列值必须相等，否则散列表就不能正常运行了。为了让散列值能够胜任散列表索引的角色，它们必须在索引空间中尽量分散开来。这意味着在最理想的状况下，越是相似但不想等的对象，它们散列值的差别应该越大。</p>
</li>
<li><p>散列表算法</p>
</li>
</ol>
<p><img src="http://oj8vattcf.bkt.clouddn.com/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95.png" alt="散列表算法"></p>
<h4 id="dict的实现及其导致的结果"><a href="#dict的实现及其导致的结果" class="headerlink" title="dict的实现及其导致的结果"></a>dict的实现及其导致的结果</h4><ol>
<li><p>键必须是可散列的</p>
<ul>
<li>支持<code>hash()</code>函数，并且通过<code>__hash()__</code>方法所得到的散列值是不变的</li>
<li>支持通过<code>__eq__()</code>方法来检测相等性</li>
<li>若<code>a == b</code>为真，则<code>hash(a) == hash(b)</code>也为真</li>
</ul>
</li>
<li><p>字典在内存上开销巨大</p>
<p>由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。</p>
</li>
<li><p>键查询很快</p>
<p>dict的实现是典型的空间换时间：字典类型有着巨大的内存开销，但它们提供了无视数据量大小的快速访问——只要字典能被装在内存里。</p>
</li>
<li><p>键的次序取决于添加顺序</p>
</li>
<li><p>往字典里添加新键可能会改变已有键的顺序</p>
<p>无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。</p>
</li>
</ol>
<h4 id="set的实现以及导致的结果"><a href="#set的实现以及导致的结果" class="headerlink" title="set的实现以及导致的结果"></a>set的实现以及导致的结果</h4><ol>
<li>集合里的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>可以很高效地判断元素是否存在于某个集合</li>
<li>元素的次序取决于被添加到集合里的次序</li>
<li>往集合里添加元素，可能会改变集合里已有元素的次序</li>
</ol>
<h2 id="文本和字节序列"><a href="#文本和字节序列" class="headerlink" title="文本和字节序列"></a>文本和字节序列</h2><h3 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">'xiehailian'</span></div><div class="line"></div><div class="line">b = s.encode(<span class="string">'utf8'</span>)  <span class="comment"># 1</span></div><div class="line">b.decode(<span class="string">'utf8'</span>)  <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<ol>
<li>使用<code>UTF-8</code>把<code>str</code>对象编码成<code>bytes</code>对象</li>
<li>使用<code>UTF-8</code>把<code>bytes</code>对象解码成<code>str</code>对象</li>
</ol>
<h3 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cafe = bytes(<span class="string">'cafe'</span>, encoding=<span class="string">'utf_8'</span>)  <span class="comment"># 1</span></div><div class="line">cafe[<span class="number">0</span>]  <span class="comment"># 2</span></div><div class="line">cafe[:<span class="number">1</span>]  <span class="comment"># 3</span></div><div class="line"></div><div class="line">cafe_arr = bytearray(cafe)  </div><div class="line">cafe_arr  <span class="comment"># 4</span></div><div class="line">cafe_arr[<span class="number">-1</span>:]  <span class="comment"># 5</span></div></pre></td></tr></table></figure>
<ol>
<li><code>bytes</code>对象可以从<code>str</code>对象使用给定的编码构建</li>
<li><code>bytes</code>的各个元素<code>range(256)</code>内的整数</li>
<li><code>bytes</code>对象的切片还是<code>bytes</code>对象，即使是只有一个字节的切片</li>
<li><code>bytearray</code>对象没有字面量句法，而是以<code>bytearray()</code>和字节序列字面量参数的形式显示</li>
<li><code>bytearray</code>对象的切片还是<code>bytearray</code>对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> array</div><div class="line">numbers = array.array(<span class="string">'h'</span>, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</div><div class="line">octets = bytes(numbers)  <span class="comment"># 1</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> struct</div><div class="line">fmt = <span class="string">'&lt;3s3sHH'</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'filter.gif'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</div><div class="line">    img = memoryview(fp.read())  <span class="comment"># 2</span></div><div class="line">header = img[:<span class="number">10</span>]  </div><div class="line">bytes(header)  </div><div class="line">struct.unpack(fmt, header)  <span class="comment"># 3</span></div><div class="line"><span class="keyword">del</span> header</div></pre></td></tr></table></figure>
<ol>
<li>将数组保存为字节序列的副本</li>
<li>使用内存中的文件内容创建一个<code>memoryview</code>对象，<code>memoryview</code>类不用于创建或存储字节序列，而是共享内存无需复制字节序列</li>
<li>拆包<code>memoryview</code>对象，得到一个元祖</li>
</ol>
<h3 id="基本的编解码器"><a href="#基本的编解码器" class="headerlink" title="基本的编解码器"></a>基本的编解码器</h3><ul>
<li>GBK</li>
<li>UTF-8</li>
</ul>
<h3 id="了解编解码问题"><a href="#了解编解码问题" class="headerlink" title="了解编解码问题"></a>了解编解码问题</h3><h4 id="处理UnicodeEncodeError"><a href="#处理UnicodeEncodeError" class="headerlink" title="处理UnicodeEncodeError"></a>处理UnicodeEncodeError</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;city = <span class="string">'São Paulo'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'utf_8'</span>)  <span class="comment"># 1</span></div><div class="line"><span class="string">b'S\xc3\xa3o Paulo'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'utf_16'</span>)</div><div class="line"><span class="string">b'\xff\xfeS\x00\xe3\x00o\x00 \x00P\x00a\x00u\x00l\x00o\x00'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'iso8859_1'</span>) </div><div class="line"><span class="string">b'S\xe3o Paulo'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'cp437'</span>) </div><div class="line">Traceback (most recent call last):</div><div class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    File <span class="string">"/.../lib/python3.4/encodings/cp437.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> encode</div><div class="line">      <span class="keyword">return</span> codecs.charmap_encode(input,errors,encoding_map)</div><div class="line">UnicodeEncodeError: <span class="string">'charmap'</span> codec can<span class="string">'t encode character '</span>\xe3<span class="string">' in position 1: character maps to &lt;undefined&gt;</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">&gt;&gt;&gt; city.encode('</span>cp437<span class="string">', errors='</span>ignore<span class="string">') </span></div><div class="line"><span class="string">b'</span>So Paulo<span class="string">'</span></div><div class="line"><span class="string">&gt;&gt;&gt; city.encode('</span>cp437<span class="string">', errors='</span>replace<span class="string">') </span></div><div class="line">b'S?o Paulo'</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'xmlcharrefreplace'</span>) </div><div class="line"><span class="string">b'São Paul</span></div></pre></td></tr></table></figure>
<ol>
<li><code>utf_?</code>，<code>iso8859_1</code>能处理这个字符串，而<code>cp437</code>不能处理这个字符串</li>
<li><code>error=&#39;ignore&#39;</code>将悄无声息地跳过无法编码的字符：这样做不太好</li>
<li>编码时指定<code>error=&#39;replace&#39;</code>，把无法编码的字符替换成<code>?</code>：数据损坏了，但是用户知道除了问题</li>
<li><code>xmlcharrefreplace</code>把无法编码的字符替换成XML实体</li>
</ol>
<h4 id="处理UnicodeDecodeError"><a href="#处理UnicodeDecodeError" class="headerlink" title="处理UnicodeDecodeError"></a>处理UnicodeDecodeError</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="string">b'Montr\xe9al'</span> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">'cp1252'</span>) </div><div class="line"><span class="string">'Montréa</span></div><div class="line"><span class="string">&gt;&gt;&gt; octets.decode('</span>utf_8<span class="string">')  # 1</span></div><div class="line"><span class="string">Traceback (most recent call last):</span></div><div class="line"><span class="string">    File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></div><div class="line"><span class="string">UnicodeDecodeError: '</span>utf<span class="number">-8</span><span class="string">' codec can'</span>t decode byte <span class="number">0xe9</span> <span class="keyword">in</span> position <span class="number">5</span>:invalid continuation byte</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">'utf_8'</span>, errors=<span class="string">'replace'</span>)  <span class="comment"># 2</span></div><div class="line"><span class="string">'Montra</span></div></pre></td></tr></table></figure>
<ol>
<li><code>utf_8</code>编解码器检测到不是有效的<code>UTF-8</code>字符串，抛出<code>UnicodeDecodeError</code></li>
<li>使用<code>replace</code>错误处理方式，使用官方指定的替换字符，表示未知字符</li>
</ol>
<h4 id="使用预期之外的编码加载模块时抛出的SyntaxError"><a href="#使用预期之外的编码加载模块时抛出的SyntaxError" class="headerlink" title="使用预期之外的编码加载模块时抛出的SyntaxError"></a>使用预期之外的编码加载模块时抛出的SyntaxError</h4><p><code>Python 3</code>默认使用<code>UTF-8</code>编码源码，<code>Python 2</code>则默认使用<code>ASCII</code>。如果加载的<code>.py</code>模块包换<code>UTF-8</code>之外的数据，而没有声明编码，会抛出<code>SyntaxError</code></p>
<h4 id="如何找出字节序列的编码"><a href="#如何找出字节序列的编码" class="headerlink" title="如何找出字节序列的编码"></a>如何找出字节序列的编码</h4><p>如何找出字节序列的编码？简单来说，不能。必须有人告诉你。</p>
<p>可以通过试探和分析找出编码，使用编码侦测包<code>Chardet</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chardetect 04-text-byte.asciidoc</div><div class="line">04-text-byte.asciidoc: utf-8 with confidence 0.99</div></pre></td></tr></table></figure>
<h4 id="BOM-有用的鬼符"><a href="#BOM-有用的鬼符" class="headerlink" title="BOM: 有用的鬼符"></a>BOM: 有用的鬼符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>u16 = <span class="string">'El Niño'</span>.encode(<span class="string">'utf_16'</span>)  <span class="comment"># 1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>u16</div><div class="line"><span class="string">b'\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x0'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>u16le = <span class="string">'El Niño'</span>.encode(<span class="string">'utf_16le'</span>)  <span class="comment"># 2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(u16le)</div><div class="line">[<span class="number">69</span>, <span class="number">0</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">105</span>, <span class="number">0</span>, <span class="number">241</span>, <span class="number">0</span>, <span class="number">111</span>, <span class="number">0</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>u16be = <span class="string">'El Niño'</span>.encode(<span class="string">'utf_16be'</span>)  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(u16be)</div><div class="line">[<span class="number">0</span>, <span class="number">69</span>, <span class="number">0</span>, <span class="number">108</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">105</span>, <span class="number">0</span>, <span class="number">241</span>, <span class="number">0</span>, <span class="number">11</span></div></pre></td></tr></table></figure>
<ol>
<li><code>b&#39;\xff\xfe&#39;</code>，就是BOM，即小字节序标记，指明编码时使用<code>Intel CPU</code>的小字节序。在小字节序设备中，各个码位的最低有效字节在前面，而大字节序设备中则相反。为了避免混肴，<code>UTF-16</code>编码在要编码的文本前面加上特殊的不可见字符<code>ZERO WIDTH NO-BREAK SPACE</code>，表明是小字节序编码。</li>
<li><code>UTF-16</code>有两种变种：<code>UTF-16LE</code>，显式指明使用小字节序；<code>UTF-16BE</code>，显式指明使用大字节序。如果使用这两个变种，不会生产BOM。</li>
</ol>
<h3 id="处理文本文件"><a href="#处理文本文件" class="headerlink" title="处理文本文件"></a>处理文本文件</h3><p>处理文本的最佳实践是，<strong><code>Unicode</code>三明治</strong> 。意思是，对于输入来说，要尽早把输入的字节序列解码成字符串；对于输出来说，则要尽量晚地把字符串编码成字节序列。</p>
<h4 id="编码默认值：一团糟"><a href="#编码默认值：一团糟" class="headerlink" title="编码默认值：一团糟"></a>编码默认值：一团糟</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys, locale</div><div class="line"></div><div class="line">expressions = <span class="string">"""</span></div><div class="line"><span class="string">        locale.getpreferredencoding()</span></div><div class="line"><span class="string">        type(my_file)</span></div><div class="line"><span class="string">        my_file.encoding</span></div><div class="line"><span class="string">        sys.stdout.isatty()</span></div><div class="line"><span class="string">        sys.stdout.encoding</span></div><div class="line"><span class="string">        sys.stdin.isatty()</span></div><div class="line"><span class="string">        sys.stdin.encoding</span></div><div class="line"><span class="string">        sys.stderr.isatty()</span></div><div class="line"><span class="string">        sys.stderr.encoding</span></div><div class="line"><span class="string">        sys.getdefaultencoding()</span></div><div class="line"><span class="string">        sys.getfilesystemencoding()</span></div><div class="line"><span class="string">    """</span></div><div class="line"></div><div class="line">my_file = open(<span class="string">'dummy'</span>, <span class="string">'w'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> expression <span class="keyword">in</span> expressions.split():</div><div class="line">    value = eval(expression)</div><div class="line">    print(expression.rjust(<span class="number">30</span>), <span class="string">'-&gt;'</span>, repr(value))</div></pre></td></tr></table></figure>
<p>对于不同操作系统，编码默认值可能是不一样的。</p>
<p>关于编码默认值的最佳建议是：别依赖默认值。如果遵从<strong><code>Unicode</code>三明治</strong>的建议，而且在程序中显式指定编码，那将避免很多问题。</p>
<h3 id="为了正确比较而规范化Unicode字符串"><a href="#为了正确比较而规范化Unicode字符串" class="headerlink" title="为了正确比较而规范化Unicode字符串"></a>为了正确比较而规范化Unicode字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'café'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'cafe\u0301'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1, s2</div><div class="line">(<span class="string">'café'</span>, <span class="string">'café'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s1), len(s2)</div><div class="line">(<span class="number">4</span>, <span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>存在这样的问题，两个字符串本质上是一样的，但python看到的是不同的码位序列，因此判定二者不相等。这就可能导致，但用户输入字符串搜索文本时，而找不到相应的文本。这个问题的解决方案是使用<code>unicodedata.normalize</code>函数提供的Unicode规范化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'café'</span>  <span class="comment"># 把"e"和重音符组合在一起</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'cafe\u0301'</span>  <span class="comment"># 分解成"e"和重音符</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s1), len(s2)</div><div class="line">(<span class="number">4</span>, <span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(normalize(<span class="string">'NFC'</span>, s1)), len(normalize(<span class="string">'NFC'</span>, s2))  <span class="comment"># 1</span></div><div class="line">(<span class="number">4</span>, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(normalize(<span class="string">'NFD'</span>, s1)), len(normalize(<span class="string">'NFD'</span>, s2))  <span class="comment"># 2</span></div><div class="line">(<span class="number">5</span>, <span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">'NFC'</span>, s1) == normalize(<span class="string">'NFC'</span>, s2)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">'NFD'</span>, s1) == normalize(<span class="string">'NFD'</span>, s2)</div><div class="line"><span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize, name</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>half = <span class="string">'½'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">'NFKC'</span>, half)  <span class="comment"># 3</span></div><div class="line"><span class="string">'1⁄2'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>four_squared = <span class="string">'4²'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>normalize(<span class="string">'NFKC'</span>, four_squared)</div><div class="line"><span class="string">'42'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>micro = <span class="string">'μ'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>micro_kc = normalize(<span class="string">'NFKC'</span>, micro)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>micro, micro_kc</div><div class="line">(<span class="string">'μ'</span>, <span class="string">'μ'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(micro), ord(micro_kc)</div><div class="line">(<span class="number">181</span>, <span class="number">956</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name(micro), name(micro_kc)</div><div class="line">(<span class="string">'MICRO SIGN'</span>, <span class="string">'GREEK SMALL LETTER MU'</span>)</div></pre></td></tr></table></figure>
<ol>
<li><code>NFC</code>是使用最少的码位构成等价的字符串，用户输入的文本默认是用<code>NFC</code>形式。不过，安全起见，保存文本之前，最好使用<code>normalize(&#39;NFC&#39;, user_text)</code>清洗字符串</li>
<li><code>NFD</code>是把组合字符分解成基字符和单独的组合字符</li>
<li><code>NFKC</code>和<code>NFKD</code>可以把兼容字符替换成一个或多兼容分解字符，使字符更可读。使用时要小心，而且只能在特殊情况中使用，例如搜索和索引，而不能用于持久存储，因为这两种转换会导致数据损失。</li>
</ol>
<h4 id="大小写折叠"><a href="#大小写折叠" class="headerlink" title="大小写折叠"></a>大小写折叠</h4><p>大小写折叠就是把所有文本变成小写，再做写其他转换。这个功能由<code>str.casefold()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>micro = <span class="string">'μ'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name(micro)</div><div class="line"><span class="string">'MICRO SIGN'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>micro_cf = micro.casefold()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name(micro_cf)</div><div class="line"><span class="string">'GREEK SMALL LETTER MU'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>micro, micro_cf(<span class="string">'μ'</span>, <span class="string">'μ'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eszett = <span class="string">'ß'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name(eszett)</div><div class="line"><span class="string">'LATIN SMALL LETTER SHARP S'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eszett_cf = eszett.casefold()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eszett, eszett_cf</div><div class="line">(<span class="string">'ß'</span>, <span class="string">'ss'</span>)</div></pre></td></tr></table></figure>
<h4 id="规范化文本匹配实用函数"><a href="#规范化文本匹配实用函数" class="headerlink" title="规范化文本匹配实用函数"></a>规范化文本匹配实用函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span><span class="params">(str1, str2)</span>:</span>  <span class="comment"># 1</span></div><div class="line">    <span class="keyword">return</span> normalize(<span class="string">'NFC'</span>, str1) == normalize(<span class="string">'NFC'</span>, str2)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span><span class="params">(str1, str2)</span>:</span>  <span class="comment"># 2</span></div><div class="line">    <span class="keyword">return</span> (normalize(<span class="string">'NFC'</span>,str1).casefold()==normalize(<span class="string">'NFC'</span>,str2).casefold())</div></pre></td></tr></table></figure>
<ol>
<li><code>NFC</code>和<code>NFD</code>可以放心使用，而且能合理比较Unicode字符串。对于大多数应用来说，<code>NFC</code>是最好的规范化形式。</li>
<li>不区分大小写的比较应该<code>str.casefold()</code></li>
</ol>
<h4 id="极端规范化：去掉变音符号"><a href="#极端规范化：去掉变音符号" class="headerlink" title="极端规范化：去掉变音符号"></a>极端规范化：去掉变音符号</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unicodedata</div><div class="line"><span class="keyword">import</span> string</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks</span><span class="params">(txt)</span>:</span></div><div class="line">    <span class="string">"""去掉全部变音符号"""</span></div><div class="line">    norm_txt = unicodedata.normalize(<span class="string">'NFD'</span>, txt)  <span class="comment"># 1</span></div><div class="line">    shaved = <span class="string">''</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c))  <span class="comment"># 2</span></div><div class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">'NFC'</span>, shaved)  <span class="comment"># 3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks_latin</span><span class="params">(txt)</span>:</span></div><div class="line">    <span class="string">"""把拉丁基字符中所有的变音符号删除"""</span></div><div class="line">    norm_txt = unicodedata.normalize(<span class="string">'NFD'</span>, txt) </div><div class="line">    latin_base = <span class="keyword">False</span></div><div class="line">    keepers = []</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt:</div><div class="line">        <span class="keyword">if</span> unicodedata.combining(c) <span class="keyword">and</span> latin_base:  </div><div class="line">            <span class="keyword">continue</span>   <span class="comment"># 忽略拉丁基字符上的变音符号</span></div><div class="line">        keepers.append(c) </div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c):  <span class="comment"># 如果不是组合字符，那就是新的基字符</span></div><div class="line">            latin_base = c <span class="keyword">in</span> string.ascii_letters</div><div class="line">    shaved = <span class="string">''</span>.join(keepers)</div><div class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">'NFC'</span>, shaved）</div><div class="line">                                 </div><div class="line">single_map = str.maketrans(<span class="string">"""‚ƒ„†ˆ‹‘’“”•–—˜›"""</span>,  <span class="comment">#  4</span></div><div class="line">                           <span class="string">"""'f"*^&lt;''""---~&gt;"""</span>)</div><div class="line"></div><div class="line">multi_map = str.maketrans(&#123;  </div><div class="line">    <span class="string">'€'</span>: <span class="string">'&lt;euro&gt;'</span>,</div><div class="line">    <span class="string">'…'</span>: <span class="string">'...'</span>,</div><div class="line">    <span class="string">'Œ'</span>: <span class="string">'OE'</span>,</div><div class="line">    <span class="string">'™'</span>: <span class="string">'(TM)'</span>,</div><div class="line">    <span class="string">'œ'</span>: <span class="string">'oe'</span>,</div><div class="line">    <span class="string">'‰'</span>: <span class="string">'&lt;per mille&gt;'</span>,</div><div class="line">    <span class="string">'‡'</span>: <span class="string">'**'</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">multi_map.update(single_map)  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dewinize</span><span class="params">(txt)</span>:</span></div><div class="line">    <span class="string">"""Replace Win1252 symbols with ASCII chars or sequences"""</span></div><div class="line">    <span class="keyword">return</span> txt.translate(multi_map)  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">asciize</span><span class="params">(txt)</span>:</span></div><div class="line">    no_marks = shave_marks_latin(dewinize(txt))     </div><div class="line">    no_marks = no_marks.replace(<span class="string">'ß'</span>, <span class="string">'ss'</span>)          </div><div class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">'NFKC'</span>, no_marks)</div></pre></td></tr></table></figure>
<ol>
<li>把所有字符分解成基字符和组合记号</li>
<li>过滤掉所有组合记号</li>
<li>重组</li>
<li>更彻底的规范化步骤是把西文文本中常见符号替换成<code>ASCII</code>的对等字符，构建字符替换映射表</li>
</ol>
<h3 id="Unicode文本排序"><a href="#Unicode文本排序" class="headerlink" title="Unicode文本排序"></a>Unicode文本排序</h3><p>不同的区域采用的排序规则有所不同，葡萄牙语等很多语言按照拉丁字母表排序，英语汉语则按照英文字母表排序。在Python中，非ASCII文本的标准排序方式是使用<code>locale.strxfrm</code>，前提是操作支持区域设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pyuca</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>coll = pyuca.Collator()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'caju'</span>, <span class="string">'atemoia'</span>, <span class="string">'cajá'</span>, <span class="string">'açaí'</span>, <span class="string">'acerola'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_fruits = sorted(fruits, key=coll.sort_key)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_fruits</div><div class="line">[<span class="string">'açaí'</span>, <span class="string">'acerola'</span>, <span class="string">'atemoia'</span>, <span class="string">'cajá'</span>, <span class="string">'caju'</span>]</div></pre></td></tr></table></figure>
<p><code>PyUCA</code>没有考虑区域设置。如果想定制排序方式，可以把自定义的排序表路径传给<code>Collator()</code>构造方法。<code>PyUCA</code>默认使用项目自带的<code>allkeys.txt</code></p>
<h3 id="Unicode数据库"><a href="#Unicode数据库" class="headerlink" title="Unicode数据库"></a>Unicode数据库</h3><p>Unicode数据库记录了字符是否可以打印、是不是字母、是不是数字，或者是不是其他数值符号。字符串的<code>isidentitier</code>、<code>isprintable</code>、<code>isdecimal</code>、<code>isnumeric</code>等方法就是靠这些信息作判断的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unicodedata</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">re_digit = re.compile(<span class="string">r'\d'</span>)</div><div class="line"></div><div class="line">sample = <span class="string">'1\xbc\xb2\u0969\u136b\u216b\u2466\u2480\u3285'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> char <span class="keyword">in</span> sample:</div><div class="line">    print(<span class="string">'U+%04x'</span> % ord(char),                       <span class="comment"># &lt;1&gt;</span></div><div class="line">          char.center(<span class="number">6</span>),                             <span class="comment"># &lt;2&gt;</span></div><div class="line">          <span class="string">'re_dig'</span> <span class="keyword">if</span> re_digit.match(char) <span class="keyword">else</span> <span class="string">'-'</span>,  <span class="comment"># &lt;3&gt;</span></div><div class="line">          <span class="string">'isdig'</span> <span class="keyword">if</span> char.isdigit() <span class="keyword">else</span> <span class="string">'-'</span>,         <span class="comment"># &lt;4&gt;</span></div><div class="line">          <span class="string">'isnum'</span> <span class="keyword">if</span> char.isnumeric() <span class="keyword">else</span> <span class="string">'-'</span>,       <span class="comment"># &lt;5&gt;</span></div><div class="line">          format(unicodedata.numeric(char), <span class="string">'5.2f'</span>),  <span class="comment"># &lt;6&gt;</span></div><div class="line">          unicodedata.name(char),                     <span class="comment"># &lt;7&gt;</span></div><div class="line">          sep=<span class="string">'\t'</span>)</div></pre></td></tr></table></figure>
<h3 id="支持字符串和字节序列的双模式API"><a href="#支持字符串和字节序列的双模式API" class="headerlink" title="支持字符串和字节序列的双模式API"></a>支持字符串和字节序列的双模式API</h3><h4 id="正则表达式中的字符串和字节序列"><a href="#正则表达式中的字符串和字节序列" class="headerlink" title="正则表达式中的字符串和字节序列"></a>正则表达式中的字符串和字节序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">re_numbers_str = re.compile(<span class="string">r'\d+'</span>)     <span class="comment"># &lt;1&gt;</span></div><div class="line">re_words_str = re.compile(<span class="string">r'\w+'</span>)</div><div class="line">re_numbers_bytes = re.compile(r<span class="string">b'\d+'</span>)  <span class="comment"># &lt;2&gt;</span></div><div class="line">re_words_bytes = re.compile(r<span class="string">b'\w+'</span>)</div><div class="line"></div><div class="line">text_str = (<span class="string">"Ramanujan saw \u0be7\u0bed\u0be8\u0bef"</span>  <span class="comment"># &lt;3&gt;</span></div><div class="line">            <span class="string">" as 1729 = 1³ + 12³ = 9³ + 10³."</span>)        <span class="comment"># &lt;4&gt;</span></div><div class="line"></div><div class="line">text_bytes = text_str.encode(<span class="string">'utf_8'</span>)  <span class="comment"># &lt;5&gt;</span></div><div class="line"></div><div class="line">print(<span class="string">'Text'</span>, repr(text_str), sep=<span class="string">'\n  '</span>)</div><div class="line">print(<span class="string">'Numbers'</span>)</div><div class="line">print(<span class="string">'  str  :'</span>, re_numbers_str.findall(text_str))      <span class="comment"># &lt;6&gt;</span></div><div class="line">print(<span class="string">'  bytes:'</span>, re_numbers_bytes.findall(text_bytes))  <span class="comment"># &lt;7&gt;</span></div><div class="line">print(<span class="string">'Words'</span>)</div><div class="line">print(<span class="string">'  str  :'</span>, re_words_str.findall(text_str))        <span class="comment"># &lt;8&gt;</span></div><div class="line">print(<span class="string">'  bytes:'</span>, re_words_bytes.findall(text_bytes))    <span class="comment"># &lt;9&gt;</span></div></pre></td></tr></table></figure>
<h4 id="os函数中的字符串和字节序列"><a href="#os函数中的字符串和字节序列" class="headerlink" title="os函数中的字符串和字节序列"></a>os函数中的字符串和字节序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">'.'</span>) </div><div class="line">[<span class="string">'abc.txt'</span>, <span class="string">'digits-of-π.txt'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">b'.'</span>) </div><div class="line">[<span class="string">b'abc.txt'</span>, <span class="string">b'digits-of-\xcf\x80.txt'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pi_name_bytes = os.listdir(<span class="string">b'.'</span>)[<span class="number">1</span>] </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pi_name_str = pi_name_bytes.decode(<span class="string">'ascii'</span>, <span class="string">'surrogateescape'</span>)  <span class="comment"># 1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pi_name_str </div><div class="line"><span class="string">'digits-of-\udccf\udc80.txt'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pi_name_str.encode(<span class="string">'ascii'</span>, <span class="string">'surrogateescape'</span>)  <span class="comment"># 2</span></div><div class="line"><span class="string">b'digits-of-\xcf\x80.t</span></div></pre></td></tr></table></figure>
<ol>
<li>使用<code>ascii</code>编解码器和<code>surrogateescape</code>错误处理方式把它解码成字符串，Windows使用的错误处理方式是<code>strict</code></li>
<li>编码成ASCII字节序列，各个代替码位还原成被替换的字节</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-03-04T08:52:32.000Z" itemprop="dateUpdated">2018-03-04 16:52:32</time>
</span><br>


        
    </div>
    <footer>
        <a href="http://printxhl.com">
            <img src="/img/avatar.jpg" alt="谢海练">
            谢海练
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/05/30/Python-FlunetPython-flow/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Fluent Python (4)：控制流程</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/05/30/Python-Django-Architecture/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Django 工程结构</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <!-- <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>footer.license</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>谢海练 &copy; 2017 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer> -->

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.6.13"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.13" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>








</body>
</html>
