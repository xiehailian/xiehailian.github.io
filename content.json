[{"title":"Redis 部署","date":"2018-05-30T06:55:04.066Z","path":"2018/05/30/DB-Redis/","text":"##Redis 安装 下载、编译、安装123456789101112131415# 下载wget http://download.redis.io/releases/redis-stable.tar.gz# 解压tar -xzvf redis-stable.tar.gz# 编译cd redis-stableyum -y install gcc automake autoconf libtool makemake# 安装cd src/cp redis-server redis-cli /usr/local/bincp redis-sentinel redis-benchmark redis-check-aof redis-check-rdb /usr/local/bin 配置文件创建配置目录1234mkdir /etc/redis # 此处存放配置文件mkdir -p /var/lib/redis/6379 # -p递归创建文件夹cp ../redis.conf /etc/redis/6379.conf vi /etc/redis/6379.conf 修改配置文件123456789101112131415161718# 启用守护进程，后台运行# 另一种后台运行方法：/usr/bin/redis-server /etc/redis.conf &amp;daemonize yes# 当Redis以守护进程方式运行时，可以通过pidfile指定pidpidfile /var/run/redis_6379.pid# 指定监听端口port 6379# 指定日志级别loglevel notice# 指定日志记录logfile /home/data/redis/6379/redis.log# 指定本地数据库存放目录dir /home/data/redis/6379 # 选择磁盘大的文件夹 创建服务创建服务1234567891011121314151617# overcommit_memory 内存分配策略 避免redis进程被杀死# 0：先检查内存是否够用；1：不管内存状态；2：允许分配超过物理内存和交换内存总和sysctl -w vm.overcommit_memory=1# 定义系统中么个端口最大监听队列长度# 对于一个经常处理新连接的高负载 web服务环境来说，要设置大一点sysctl -w net.core.somaxconn=512# transparent hugepage允许hugepage可以动态分配，而不是系统启动时预先分配# 直接关闭THP(比如说Oracle、MongoDB等)，否则可能导致性能下降，内存锁，甚至系统重启等问题echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled# redis启动，关闭脚本cp utils/redis_init_script /etc/init.d/redis_6379# 创建redis服务vi /etc/systemd/system/redis.service redis.service的内容12345678[Unit]Description=Redis on port 6379[Service]Type=forkingExecStart=/etc/init.d/redis_6379 startExecStop=/etc/init.d/redis_6379 stop[Install]WantedBy=multi-user.target [Unit]：启动顺序与依赖关系 Description：当前服务的简单描述 [Service]：定义如何启动当前服务 Type：启动类型 forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程 ExecStart：定义启动进程时执行的命令 ExecStop：停止服务时执行命令 Install：定义该服务所在的Target，即怎样做到开机启动 WantedBy：表示所在服务的Target multi-user.target：多用户启动 指定这个target后，这个组里的所有服务，通过执行systemctl enable命令就可以开机启动了 服务更新12345678# 设置redis开机启动systemctl enable redis# 服务重载systemctl daemon-reload# 启动systemctl start redis 订阅与发布http://redisbook.readthedocs.io/en/latest/feature/pubsub.html “Error while extracting response for type and content type [application/json;charset=UTF-8]; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize instance of java.util.ArrayList out of START_OBJECT token; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of java.util.ArrayList out of START_OBJECT token↵ at [Source: (PushbackInputStream); line: 1, column: 1]” https://www.cnblogs.com/cnmenglang/p/6225987.html","tags":[{"name":"DB","slug":"DB","permalink":"http://printxhl.com/tags/DB/"}]},{"title":"Linux 基本操作","date":"2018-05-30T06:55:03.128Z","path":"2018/05/30/Linux-Base/","text":"用过的一些命令1234567891011# 复制时，使用日期名作为文件名cp direct.log direct.log.$(date +%Y%m%d)# 将后台运行程序的打印记录立即输出到nohup.out文件nohup python -u spider.py &gt; nohup.out 2&gt;&amp;1 &amp;# 交换空间扩容dd if=/dev/zero of=/home/swap bs=1024 count=8192000# 获取pid, 杀死进程cat uwsgi.pid | xargs kill -9 Linux 用户管理查看用户1who am i 创建用户12345678910# sudo &lt;cmd&gt; 以特权级别运行cmd命令，需要当前用户属于sudo组且输入当前用户密码# adduser创建用户后，创建home目录，然后会提示你创建密码# useradd只创建用户，创建完后用passwd lilei去设置密码sudo adduser lilei # 切换到用户su lilei # 切换到目录，同时环境变量也会跟着改变成目标用户的环境变量su - lilei 用户组用户组是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。 1234567891011121314# 查看所属用户组 # cat /etc/group | grep -E \"shiyanlou\"groups lilei# 看lilei是否在sudoers用户组su - lileisudo ls logout# 将用户添加到sudo用户组的方法$ vim /etc/sudoers# %wheel ALL=(ALL) ALL # sudo命令，要输密码# %wheel ALL=(ALL)NOPASSWD:ALL # sudo命令，不要输密码usermod -G wheel es # 将es用户添加到wheel用户，就可使用sudo命令 删除用户123userdel petergroupdel peter Linux 文件权限查看文件权限123ls -l总用量 4-rw-r--r--. 1 root root 642 4月 17 14:33 regular_express.txt -rw-r–r– 1 root root 642 4月 17 14:33 *.txt 文件类型和权限 链接数 所有者 用户组 文件大小 最后修改时间 文件名 变更文件所有者1chown &lt;user&gt; &lt;file&gt; 修改文件权限1234567# 二进制数字表示# 仅对拥有着可读可写可执行 rwx = 1*4+1*2+1*1chmod 700 &lt;file&gt; # 加减赋值操作# g代表group, o代表others, u代表user，+-代表加减相应权限chmod go-rw &lt;file&gt; Linux 目录结构 bin：一般用户可用，启动时会用到的命令，即文件系统还没被挂载时，也能使用的命令 boot grub：开机设置相关文件 vmlinuz：内核文件 dev：存放设置文件 etc：包含系统特有的可编辑配置文件，即用于控制程序运行的本地文件 home：用户家目录 lib：用于存放程序的动态库和模块文件 media：用于挂载本地磁盘或其他存储设备，U盘之类的 mnt：用于挂载其他临时文件系统 opt：发行版附加的一些软件包的安装目录 root：root用户的家 sbin：存放root用户才能执行的命令，一些系统进行更新，备份，还原和开机用到的命令 srv：存放服务进程所需的数据文件和一些服务的执行脚本 tmp：存放各种临时文件 usr：用于存储只读用户数据的第二层次，包含绝大多数的用户工具和应用程序 bin：非必要可执行文件，面向所有用户 include：标准包含头文件 lib：/usr/bin和/usr/sbin/中二进制文件的库 local：本地数据第三层次，具体到本台主机 share：体系结构无关的共享数据 sbin：非必要的系统二进制文件 src：源代码，内核源代码及其头文件 var：变量文件，在正常运行的系统中其内容不断变化的的文件，如日志之类的 可分享的(shareable) 不可分享的(unshareable) 不可变的(static) /usr, /opt /etc, /boot 可变动的(variable) /var/mail, /var/news /var/run, /var/lock Linux 文件的基本操作 新建 123456# 新建文件touch test# 新建目录mkdir mydirmkdir -p father/son/grandson # -p递归创建目录 复制 12345# 复制文件cp test /father/son/grandson# 复制目录cp -r father family 删除 12345# 删除文件rm -f test# 删除目录rm -rf family 移动文件与文件重命名 123456789# 移动文件mv &lt;file&gt; &lt;document&gt;# 重命名mv &lt;file&gt; &lt;file&gt;# 批量重命名touch file&#123;1..5&#125;.txt # 使用通配符批量创建5个文件rename 's/\\.txt\\/.c/' *.txt # 批量重命名 查看文件 123456789101112# 使用cat, tac和nl命令查看文件cat -n &lt;file&gt; # 正序查看，-n加上行号tac &lt;file&gt; # 倒序查看nl &lt;file&gt; # 添加行号并打印# 使用more和less命令分页查看文件more &lt;file&gt; # 一直往下看less &lt;file&gt; # 来回看# 使用head和tail命令查看文件head -n 5 &lt;file&gt; # 指定看头5行tail -f &lt;file&gt; # 动态查看日志 查看文件类型 1file /bin/ls 环境变量变量分类按变量的类型划分，Linux变量可分为： 自定义变量：当前Shell进程私有用户自定义的变量 123declare tmp # 自定义变量tmp = xiehailian # 赋值echo $tmp # 打印变量 内建变量：Shell本身内建的变量 环境变量：从自定义变量导出的环境变量 12345678# 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量set# 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行env# 显示从Shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量export 按照变量的生存周期来划分，Linux变量可分为： 永久的变量：需要修改配置文件，变量永久生效 临时的变量：使用export命令声明即可，变量在关闭shell时失效 1234567# 只针对bash初始化vim /etc/bashrc # 存放的是环境变量，永久生效vim ~/.bashrc # 只对当前用户永久生效# 统一初始化的地方vim /etc/profile # 存放的是环境变量, 永久生效vim ~/.profile # 只对当前用户永久生效 环境变量操作1234567891011121314# 命令的查找路径与顺序# 当在Shell中执行一个命令时，系统会按照PATH中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个echo $PATH/root/anaconda3/bin:/usr/local/jdk/bin:/usr/local/apache-maven/bin:/usr/local/jdk/bin:/usr/local/mongodb/bin:/home/hadoop/anaconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/scala/bin:/usr/local/hadoop/hadoop/bin:/usr/local/hadoop/hadoop/sbin:/usr/local/hadoop/spark/bin:/root/bin# 添加自定义路径到PATH环境变量echo \"PATH=$PATH:/home/shiyanlou/mybin\" &gt;&gt; .bashrc# 修改和删除已有变量path=$&#123;path%/home/shiyanlou/mybin&#125; # 从后删除匹配字符串unset path # 删除一个变量# 让环境变量立即生效source .profile 搜索文件1234567891011121314151617181920# 将目前目录及其子目录下所有延伸档名是 c 的文件列出来find . -name \"*.c\"# 将当前目录下子目录中所有一般文件列出find . -type f# 将目前目录及其子目录下所有最近 20 天内更新过的文件列出find . -ctime -20# 查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们find /var/logs -type f -mtime +7 -ok rm &#123;&#125; \\;# 查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件find . -type f -perm 644 -exec ls -l &#123;&#125; \\;# 为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径find / -type f -size 0 -exec ls -l &#123;&#125; \\;# 查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们find /var/logs -type f -mtime +7 -ok rm &#123;&#125; \\; 文件打包与解压缩 使用zip打包，使用unzip解压 123456789101112# 使用zip打包文件夹# -r参数表示递归打包，-q表示安静模式不向屏幕输出信息，-o表示输出文件紧跟文件名zip -r -q -o superpub.zip ./superpub# 设置压缩级别为9和1，重新打包，1表示最快压缩体积大，9表示体积小耗时久zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou -x ~/*.zip# 创建加密zip包，使用-e参数zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou# 使用安静模式，将文将解压到指定目录unzip -q shiyanlou.zip -d ziptest 使用tar打包和解压 1234567891011121314# 打一个tar包，-c表示打包，-f指定文件名tar -cf shiyanlou.tar shiyanlou# 解压一个tar包，-x表示解包，-C表示指定路径tar -xf shiyanlou.tar -C /home# -t表示只查看不解包文件tar -tf shiyanlou.tar# -z表示使用gzip来压缩文件tar -czf shiyanlou.tar.gz shiyanlou# 解压.tar.gz文件tar -xzf shiyanlou.tar.gz 分割合并压缩包 1split -b 500M ask_20180515.json.tar.gz -d -a 3 ask 文件系统操作使用df命令查看磁盘的容量1234567891011121314$ df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 14G 24G 36% / # 主机硬盘分区devtmpfs 7.8G 0 7.8G 0% /devtmpfs 7.8G 0 7.8G 0% /dev/shmtmpfs 7.8G 508K 7.8G 1% /runtmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup/dev/vdb1 493G 42G 426G 9% /mnt # 主机硬盘分区tmpfs 1.6G 0 1.6G 0% /run/user/0# 查看目录挂载点$ df /opt -vh文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 50G 1.7G 49G 4% / 使用du命令查看目录的容量1234567891011121314151617# 显示所有文件及目录大小du # -h表示人类易读方式du -h # -d指定参看目录的深度，只查看1级目录du -h -d 0 # 查看2级目录du -h -d 1 # 显示目录中所有文件大小du -a # 仅显示最后加总的值du -s 磁盘管理命令执行顺序控制与管道123# 以下两个命令的结果是不同的cat -n regular_express.txt | grep '^#cat regular_express.txt | grep -n '^#' Linux 下软件安装通常 Linux 上的软件安装主要有四种方式： 在线安装 从磁盘安装deb软件包 从二进制软件包安装 从源代码编译安装 安装包卸载12rpm -qa | grep mysqlrpm -e mysql80-community-release-el7-1.noarch ###","tags":[{"name":"linux","slug":"linux","permalink":"http://printxhl.com/tags/linux/"}]},{"title":"Docker","date":"2018-05-30T06:55:02.401Z","path":"2018/05/30/Linux-Docker/","text":"Doker 安装、卸载、加速 安装docker 1yum -y install docker 启动docker后台服务 1service docker start 列出安装过的包 1yum list installed | grep docker 卸载安装包 1yum -y remove docker-engine.x86_64 删除镜像/容器 1rm -rf /var/lib/docker 删除某个容器 12docker stop 4aaa117cc44ddocker rm 4aaa117cc44d 删除某个镜像 1docker rmi dongweiming/web_develop Docker加速 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;: [&quot;https://xyv3tri5.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker Docker基本命令 拉取docker镜像 1docker pull dongweiming/web_develop:lastest 显示docker镜像 1docker images 进入容器 1docker run --name web_dev -it -p 9000:9000 -p 3141:3141 -p 5000:5000 dongweiming/web_develop /bin/zsh -i：在新容器里指定一个伪终端 -t：允许你对容器内的标准输入进行交互 -d：以进程方式后台运行容器 -p：显示暴露特定端口 后台运行容器 1docker run -dit -p 9000:9000 -p 3141:3141 -p 5000:5000 dongweiming/web_develop /bin/zsh 显示后台运行的容器 1docker ps -a 调用后台容器 1docker attach 4aaa117cc44d 退出时，使用[ctrl + D]，这样会结束docker当前线程，容器结束，可以使用[ctrl + P][ctrl + Q]退出而不终止容器运行 停止容器 1docker stop 4aaa117cc44d Docker容器使用 后台运行容器 1docker run -dit -P dongweiming/web_develop 进入容器 1docker attach 4aaa117cc 后台运行容器内的程序 1nohup python chapter3/section1/hello.py &amp; 查看端口映射，使用浏览器访问http://120.77.217.212:32772/ 1docker ps -a 查看端口映射情况 1docker port 30ef932cc51f 查看容器内应用程序日志 1docker logs -f 30ef932cc51f 检查应用程序的状态信息 1docker inspect 30ef932cc51f 停止容器内应用程序 1docker stop 30ef932cc51f 启动应用容器 1docker start 30ef932cc51f 移除应用容器 1docker rm 30ef932cc51f Docker镜像使用 查找镜像 1docker search redis 从已经创建的容器中更新镜像，并且提交这个镜像 1docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2 使用Dockerfile指令来创建一个新的镜像 1docker build -t runoob/centos:6.7 . 设置标签镜像 1docker tag 860c279d2fec runoob/centos:dev Docker容器连接 网络端口映射 12docker run -d -P training/webappdocker run -d -p 5000:5000 training/webapp -P：容器内部端口随机映射到主机的高端口 -p：容器内部端口绑定到主机端口 容器命名 1docker run -d -P --name runoob training/webapp 文件传输 获取ID全称 1docker inspect -f &apos;&#123;&#123;.id&#125;&#125;&apos; 30ef932cc51f 文件传输 1docker cp 本地文件路径 ID全称:容器路径 Docker 安装jupyterhttps://segmentfault.com/a/1190000007448177 Docker Hub使用http://wiki.jikexueyuan.com/project/docker/userguide/dockerrepos.html","tags":[{"name":"Linux","slug":"Linux","permalink":"http://printxhl.com/tags/Linux/"}]},{"title":"Hexo Blog","date":"2018-05-30T06:55:02.044Z","path":"2018/05/30/Linux-HexoBlog/","text":"Hexo 本地建站安装环境 安装Node.js 安装Git 安装Hexo 1$ npm install -g hexo-cli 建立站点1234567891011121314# 新建xiehailian.github.io文件夹$ cd /c/Users/XHL/OneDrive$ mkdir xiehailian.github.io# 更新NPM镜像$ npm config set registry 'https://registry.npm.taobao.org'# 初始化网站$ cd /c/Users/XHL/OneDrive/xiehailian.github.io$ hexo init$ npm install# 启动网站$ hexo server 使用主题indigo安装indigo12345678910111213141516# 下载主题$ cd /c/Users/XHL/OneDrive/xiehailian.github.io$ git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo# 安装依赖$ npm install hexo-renderer-less --save # css预处理工具$ npm install hexo-generator-feed --save # 生成rss$ npm install hexo-generator-json-content --save # 站内搜索# 开启标签页$ hexo new page tags$ vi /c/Users/XHL/OneDrive/xiehailian.github.io/source/tags/index.md layout: tags comments: false --- 站点配置123456789101112131415161718192021222324252627282930313233343536373839$ vim /c/Users/XHL/OneDrive/xiehailian.github.io/_config.yml# 启用主题theme: indigo# 基本配置title: PrintXHLsubtitle: 我就想做一点微小的工作description: author: 谢海练language:timezone:email: xiehailian66@126.com# feed配置feed: type: atom path: atom.xml limit: 0 # jsonContent配置jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 主题配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354$ vi /c/Users/XHL/OneDrive/xiehailian.github.io/themes/indigo/._config.yml# 左侧菜单menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/xiehailian target: _blank link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开# favicon，站点logofavicon: /favicon.ico# 头像avatar: /img/logo.jpg# emailemail: xiehailian66@126.com# colorcolor: '2361b6'# 文章摘要excerpt_render: false # 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_length: 200 # 截断长度excerpt_link: 阅读全文... # 文字正文页链接文字# 公式渲染mathjax: true# 站内搜索search: true# 布局hideMenu: true# 文章目录toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul # less编译入口less: compress: true # 是否压缩css paths: - source/css/style.less 生成自己的内容12345$ hexo generate$ hexo server -p 6688# 清楚缓存文件和静态文件$ hexo clean 部署到GithubGithub 授权123456789101112131415161718# 在Github上新建仓库，xiehailian.github.io# 告诉Github代码是谁提交的$ git config --global user.name \"xiehailian\"$ git config --global user.email \"xiehailian66@126.com\"# 生成SSH key$ ssh-keygen -t rsa -b 4096 -C \"xiehailian66@126.com\"# 将SSH key添加到ssh-agent$ eval \"$(ssh-agent -s)\"$ ssh-add ~/.ssh/id_rsa# 将SSH key添加到Github账户$ clip &lt; ~/.ssh/id_rsa.pub# 测试SSH连接$ ssh -T git@github.com Hexo 部署12345678910$ npm install hexo-deployer-git --save$ vim /c/Users/XHL/OneDrive/xiehailian.github.io/_config.ymldeploy: type: git repo: https://github.com/xiehailian/xiehailian.github.io.git branch: master $ hexo deploy 绑定独立域名","tags":[{"name":"Linux","slug":"Linux","permalink":"http://printxhl.com/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"http://printxhl.com/tags/Git/"}]},{"title":"Fluent Python (4)：控制流程","date":"2018-05-30T06:55:01.296Z","path":"2018/05/30/Python-FlunetPython-flow/","text":"可迭代的对象、迭代器和生成器Sentence类第1版：单词序列实现一个Sentence类，实现序列协议，这个类对象可以迭代 123456789101112131415161718import reimport reprlibRE_WORD = re.compile('\\w+')class Sentence: def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) # &lt;1&gt; def __getitem__(self, index): return self.words[index] # &lt;2&gt; def __len__(self, index): # &lt;3&gt; return len(self.words) def __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text) # &lt;4&gt; re.findall函数返回一个字符串列表，里面的元素是正则表达式的全部非重叠匹配 self.words中保存的是.findall函数返回的结果，因此直接返回指定索引位上的单词 为了完善序列协议，实现了__len__方法，但是如果只是为了让对象可以迭代，没必要实现这个方法 reprlib.repr这个实用函数用于生成大型数据结构的简略字符串表示形式，默认情况下生成的字符串最多有30个字符 序列可以迭代的原因：iter函数解释器需要迭代对象x时，会自动调用iter(x)函数。iter(x)有以下作用： 检查对象是否实现了__iter__方法，如果实现了就调用它，获取一个迭代器 如果没有实现__iter__方法，但实现了__getitem__方法，Python会创建要给迭代器，尝试按顺序获取元素 如果尝试失败，Python抛出TypeError异常，告知你对象不可迭代 可迭代对象 vs 迭代器可迭代的对象 __iter__，实现了此方法，那对象就是可迭代的 __getitem__，或者实现了此方法，而且其参数是从零开始索引，那对象也是可迭代的 迭代器 __next__，必须实现此方法，返回序列中下一个元素，如果没有元素了，那么就抛出StopIteration异常 __iter__，还需要实现此方法，所以迭代器才可以迭代 Sentence类第2版：典型的迭代器使用迭代器模式实现Sentence类。 12345678910111213141516class SentenceIterator: def __init__(self, words): self.words = words self.index = 0 def __next__(self): try: word = self.words[self.index] except IndexError raise StopIteration() self.index += 1 return word def __iter__(self): return self 把Sentence变成迭代器：坏主意 构建可迭代的对象和迭代器时经常会出现错误，原因是混肴了二者。 迭代器可以迭代，但是可迭代对象不是迭代器。 迭代器一般要支持多种遍历，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且每个迭代器要能维护自身内部状态 这一模式正确的实现方式是，每次调用iter(my_iterable)都新建一个独立迭代器，这就是为什么要重新定义一个SentenceIterator类 Sentence类第3版：生成器函数生成器可以实现和迭代器相同的功能，用生成器函数来代替SentenceIterator类更符合Python的习惯。 123456789101112131415161718import reimport reprlibRE_WORD = re.compile('\\w+')class Sentence: def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text) def __iter__(self): for word in self.words: yield word # 1 return # 2 用yield产出当前的word 这个return语句是不必要的，这个函数可以直接落空，自动返回。不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成完全部值后直接退出 不再需要单独定义一个迭代器的类！这里的迭代器其实是生成器对象，每次调用__iter__方法都会自动创建，因为这里的__iter__方法是生成器函数 生成器函数的工作原理 只要Python函数定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回生成器对象。也就是说，生成器函数是生成器工厂。 生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给next()函数时，生成器函数就会向前，执行函数定义体中的下一个yield语句，返回产出的值，并在函数定义体的当前位置暂停，最终函数定义体返回时，外层的生成器对象抛出StopIteration异常。 Sentence类第4版：惰性实现惰性实现是指，尽可能延后生成值，这样做能节省内存，而且或许还可以避免做无用的处理。 之前版本的Sentence类都不具有惰性，因为__init__方法急迫地构建好了文本中的单次列表，然后将其绑定到self.words属性上。这样就得处理整个文本，列表使用的内存量可能与文本本身一样多。如果只需迭代前几个单次，那么大多数工作都是白费力气。 只要使用是Python 3，思索着做某件事有没有懒惰的方式，答案通常都是肯定的。 12345678910111213141516import reimport reprlibRE_WORD = re.compile('\\w+')class Sentence: def __init__(self, text): self.text = text # &lt;1&gt; def __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text) def __iter__(self): for match in RE_WORD.finditer(self.text): # &lt;2&gt; yield match.group() # &lt;3&gt; 不再需要words列表 re.finditer函数是re.findall函数的惰性版本，返回的不是列表，而是生成器，按需生成re.MatchObject实例。如果有很多匹配，re.finditer函数能节省大量内存。惰性实现可以在需要时才生成一个单词 match.group()方法从MathcObject实例中提取匹配正则表达式的具体文本 Sentence类第5版：生成器表达式生成器表达式可以理解为列表推导惰性版本，不迫切地构建列表，而是返回一个生成器，按需生成元素。 123456789101112131415import reimport reprlibRE_WORD = re.compile('\\w+')class Sentence: def __init__(self, text): self.text = text def __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text) def __iter__(self): return (match.group() for match in RE_WORD.finditer(self.text)) 何时使用生成器表达式如果生成器表达式要分开多行写，那就定义生成器函数，以便提高可读性。 另一个示例：等差数列生成器123456789101112131415class ArithmeticProgression: def __init__(self, begin, step, end=None): # &lt;1&gt; self.begin = begin self.step = step self.end = end # None -&gt; \"infinite\" series def __iter__(self): result = type(self.begin + self.step)(self.begin) # &lt;2&gt; forever = self.end is None # &lt;3&gt; index = 0 while forever or result &lt; self.end: # &lt;4&gt; yield result # &lt;5&gt; index += 1 result = self.begin + self.step * index # &lt;6&gt; __init__方法需要两个参数：begin和step。end是可选的，如果值是None，那么生成的是无穷数列 把self.begin赋值给result，不过会先强制转换成前面的加法算式得到类型 如果self.end属性的值是None，那么forever的值是True，因此生成的是无穷数列 这个循环要么一直执行下去，要么当result大于或等于self.end时结束。如果循环退出了，那么这个函数也随之退出 使用生成器函数实现12345678def aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) forever = end is None index = 0 while forever or result &lt; end: yield result index += 1 result = begin + step * index 使用itertools模块生成等差数列12345678import itertoolsdef aritprog_gen(begin, step, end=None): first = type(begin + step)(begin) ap_gen = itertools.count(first, step) # 1 if end is not None: ap_gen = itertools.takewhile(lambda n: n &lt; end, ap_gen) # 2 return ap_gen itertools.count函数返回的生成器能生成多个数，且从不停止 itertools.takewhile函数会生成一个使用另一个生成器生成器，在指定的条件计算结果为False时停止 yield fromyield from i完全可以代替内层的for循环 123456&gt;&gt;&gt; def chain(*iterables):... for i in iterables:... yield from i...&gt;&gt;&gt; list(chain(s, t))['A', 'B', 'C', 0, 1, 2] 可迭代的归约函数接受可迭代对象作为参数，最终返回单个结果 all，any，max，min，sum，functools.reduce 深入分析iter函数1234&gt;&gt;&gt; def d6():... return randint(1, 6)&gt;&gt;&gt; d6_iter = iter(d6) # 1&gt;&gt;&gt; d6_iter = iter(d6, 1) # 2 迭代对象d6时会调用iter(d6) 传入两个参数，第一个参数必须是可调用的对象，第二个值是哨符。当可调用对象返回这个值时，触发迭代器抛出StopIteration异常，而不产生哨符 把生成器当成协程 .send()方法允许在客户代码和生成器之间双向交换数据 .__next__()方法只允许客户从生成器中获取数据 上下文管理器和else块if语句之外else块在所有情况下，如果异常或者return、break或continue语句导致控制权跳到了复合语句的主块之外，else子句也会被跳过 for...else 仅当for循环运行完毕时，即for循环没有被break语句终止时才运行else块 while...else 仅当while循环因为条件为假值而推出时，即while循环没有被break语句终止才运行else块 try...else 仅当try块没有异常抛出时才运行else块 上下文管理器和with块上下文管理器对象存在的目的是管理with语句，就像迭代器的存在是为了管理for语句一样。 with语句的目的是简化try/finally模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、return语句或sys.exit()调用而终止，也会执行指定操作。finally子句中的代码通常用于释放重要资源，或者还原临时变更的状态。 1234567891011121314151617class LookingGlass: def __enter__(self): # &lt;1&gt; import sys self.original_write = sys.stdout.write # &lt;2&gt; sys.stdout.write = self.reverse_write # &lt;3&gt; return 'JABBERWOCKY' def reverse_write(self, text): self.original_write(text[::-1]) def __exit__(self, exc_type, exc_value, traceback): # &lt;4&gt; import sys # &lt;5&gt; sys.stdout.write = self.original_write # &lt;6&gt; if exc_type is ZeroDivisionError: # &lt;7&gt; print('Please DO NOT divide by zero!') return True with语句开始运行时，会在上下文管理器对象上调用__enter__方法。除了self之外，调用__enter__方法时不传入其他参数 把原来的sys.stdout.write方法保存在一个实例属性中，供后面使用 为sys.stdout.write打猴子补丁，替换成自己编写方法 with语句运行结束后，会在上下文管理器对象调用__exit__方法，以此扮演finally子句的角色。如果一切正常，调用__exit__方法传入参数是全是None。如果抛出了异常，这个三个参数是异常数据 重复导入模块不会消耗很多资源，因为Python会缓存导入模块 还原成原来的sys.stdout.write方法 如果有异常，而且是ZeroDivisionError类型，打印一个消息，然后返回True，告诉解释器，异常已经处理 contextlib模块中实用工具使用contextlib自定义上下文管理器 closing suppress @contextmanager ContextDecorator ExitStack 使用@contextmanager@contextmanager装饰器能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义__enter__和__exit__方法，而只需实现有一个yield语句的生成器，生成想让__enter__方法返回的值。 在使用@contextmanager装饰的生成器中，yield语句的作用是把函数的定义体分成两部分：yield语句前面的所有代码在with块开始时执行即调用__enter__方法，yield语句后面的代码在with块结束时执行即调用__exit__方法 123456789101112131415161718192021222324import contextlib@contextlib.contextmanager def looking_glass(): import sys original_write = sys.stdout.write def reverse_write(text): original_write(text[::-1]) sys.stdout.write = reverse_write msg = '' try: yield 'JABBERWOCKY' # &lt;1&gt; except ZeroDivisionError: # &lt;2&gt; msg = 'Please DO NOT divide by zero!' finally: # &lt;3&gt; sys.stdout.write = original_write # &lt;4&gt; if msg: print(msg) &gt;&gt;&gt; with looking_glass() as what:... print('hehe')... print(what) 产出一个值，这个值会绑定到with语句中as子句的目标变量上，执行with块中的代码时，这个函数会在这一点暂停 捕获ZeroDivisionError异常 如果出现异常，looking_glass函数将会终止，将无法恢复原来的sys.stout.write方法，导致系统处于无效状态。因此要使用try...except...finally语句定义最终状态 控制权一旦跳出with块，继续执行yield语句之后的代码：这里是恢复成原来的sys.stout.write方法 协程生成器如何进化成协程 生成器的调用方可以使用.send()方法发送数据，发送的数据会成为生成器函数中yield表达式的值 生成器可以作为协程使用，协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值 用作协程的生成器的基本行为123456789101112131415&gt;&gt;&gt; def simple_coroutine(): # 1 ... print('-&gt; coroutine started') ... x = yield # 2 ... print('-&gt; coroutine received:', x) ...&gt;&gt;&gt; my_coro = simple_coroutine()&gt;&gt;&gt; my_coro &lt;generator object simple_coroutine at 0x100c2be10&gt;&gt;&gt;&gt; next(my_coro) # 3-&gt; coroutine started&gt;&gt;&gt; my_coro.send(42) # 4-&gt; coroutine received: 42Traceback (most recent call last): # 5 ...StopIteration 协程使用生成器函数定义：定义体中有yield关键字 yield在表达式中使用；如果协程只需从客户那里接受数据，那么产出的值是None，这个值是隐式指定的，因为yield关键字右边没有表达式 首先要调用next()函数，因为生成器还没启动，没在yield语句处暂停，所以一开始无法发送数据，最先调用next()函数通常称为预激协程 调用send()方法，协程定义体中的yield表达式会计算出42；现在协程会恢复，一直运行到下一个yield表达式或者终止 控制权流动到协程定义体的末尾，导致生产器像往常一样抛出StopIteration异常 1234567891011121314151617181920212223242526&gt;&gt;&gt; def simple_coro2(a): ... print('-&gt; Started: a =', a) ... b = yield a ... print('-&gt; Received: b =', b) ... c = yield a + b ... print('-&gt; Received: c =', c) ...&gt;&gt;&gt; my_coro2 = simple_coro2(14)&gt;&gt;&gt; from inspect import getgeneratorstate&gt;&gt;&gt; getgeneratorstate(my_coro2) # 1'GEN_CREATED'&gt;&gt;&gt; next(my_coro2) -&gt; Started: a = 1414&gt;&gt;&gt; getgeneratorstate(my_coro2) # 2'GEN_SUSPENDED'&gt;&gt;&gt; my_coro2.send(28) # 3-&gt; Received: b = 2842&gt;&gt;&gt; my_coro2.send(99) -&gt; Received: c = 99Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;StopIteration&gt;&gt;&gt; getgeneratorstate(my_coro2) # 4'GEN_CLOSE inspect.getgeneratorstate函数表明，处于GEN_CREATED状态，即协程未启动 inspect.getgeneratorstate函数表明，处于GEN_SUSPENDED状态，即协程在yield表达式处暂停 把数字28发给暂停的协程：计算yield表达式，得到28，再把这个数绑定给b。产出a+b的值，然后协程暂停，等待为c赋值 inspect.getgeneratorstate函数表明，处于GEN_CLOSED状态，即协程执行结束 使用协程计算移动平均值123456789def averager(): total = 0.0 count = 0 average = None while True: # &lt;1&gt; term = yield average # &lt;2&gt; total += term count += 1 average = total/count 这个无限循环表明，只要调用方不断把值发给这个协程，它就会一直收值，然后生成结果。仅当调用方在协程上调用.close()方法，或者没有对协程的引用而被垃圾回收程序回收时，这个协程才会终止 这里的yield表达式用于暂停执行协程，把结果发给调用方：还用于接受调用方后面发给协程的值，恢复无限循环 使用协程的好处是，total和count不必声明为全局变量，无需使用实例属性或闭包在多次调用之间保持上下文 预激协程的装饰器如果不预激，那么协程也就没什么用。为了简化协程的用法，有时会使用一个预激装饰器。 123456789101112131415161718192021from functools import wrapsdef coroutine(func): \"\"\"Decorator: primes `func` by advancing to first `yield`\"\"\" @wraps(func) def primer(*args,**kwargs): # &lt;1&gt; gen = func(*args,**kwargs) # &lt;2&gt; next(gen) # &lt;3&gt; return gen # &lt;4&gt; return primer @coroutine # &lt;5&gt;def averager(): # &lt;6&gt; total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/count 把被装饰的生成器函数替换成这里的primer函数；调用primer函数时，返回预激后的生成器。 预激生成器，返回生成器 把装饰器应用到averager函数上 终止协程和异常处理未处理的异常会导致协程终止。 1234567891011121314151617181920212223242526272829303132class DemoException(Exception): \"\"\"An exception type for the demonstration.\"\"\"def demo_exc_handling(): print('-&gt; coroutine started') while True: try: x = yield except DemoException: # &lt;1&gt; print('*** DemoException handled. Continuing...') else: print('-&gt; coroutine received: &#123;!r&#125;'.format(x)) raise RuntimeError('This line should never run.') # 激活&gt;&gt;&gt; from inspect import getgeneratorstate&gt;&gt;&gt; exc_coro = demo_exc_handling()&gt;&gt;&gt; next(exc_coro)-&gt; coroutine started&gt;&gt;&gt; exc_coro.send(11)-&gt; coroutine received: 11 # 如果关闭&gt;&gt;&gt; exc_coro.close() # 2&gt;&gt;&gt; getgeneratorstate(exc_coro)'GEN_CLOSED'# 如果传入异常&gt;&gt;&gt; exc_coro.throw(DemoException) # 3*** DemoException handled. Continuing...&gt;&gt;&gt; getgeneratorstate(exc_coro)'GEN_SUSPENDED' 特别处理DemoException异常 .close()方法致使生成器在暂停的yield表达式抛出GeneratorExit异常。如果生成器没有处理这个异常，或者抛出StopIteration异常，调用方也不会报错 .throw方法可以使生成器在暂停的yield表达式抛出指定异常，不会导致协程终止 让协程返回值12345678910111213141516171819202122232425262728from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): total = 0.0 count = 0 average = None while True: term = yield if term is None: break # &lt;1&gt; total += term count += 1 average = total/count return Result(count, average) # &lt;2&gt;&gt;&gt;&gt; coro_avg = averager()&gt;&gt;&gt; next(coro_avg)&gt;&gt;&gt; coro_avg.send(10)&gt;&gt;&gt; coro_avg.send(30)&gt;&gt;&gt; coro_avg.send(6.5)&gt;&gt;&gt; try: ... coro_avg.send(None) ... except StopIteration as exc: # 3 ... result = exc.value &gt;&gt;&gt; resultResult(count=3, average=15.5) 为了返回值，协程必须正常终止 返回一个nametuple，包含count和average两个字段 捕获StopIteration异常，获取averager返回的值 使用yield from1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from collections import namedtupleResult = namedtuple('Result', 'count average')# the subgeneratordef averager(): # &lt;1&gt; total = 0.0 count = 0 average = None while True: term = yield # if term is None: # &lt;3&gt; break total += term count += 1 average = total/count return Result(count, average) # &lt;4&gt;# the delegating generatordef grouper(results, key): # &lt;5&gt; while True: # &lt;6&gt; results[key] = yield from averager() # &lt;7&gt;# the client code, a.k.a. the callerdef main(data): # &lt;8&gt; results = &#123;&#125; for key, values in data.items(): group = grouper(results, key) # &lt;9&gt; next(group) # &lt;10&gt; for value in values: group.send(value) # &lt;11&gt; group.send(None) # important! &lt;12&gt; # print(results) # uncomment to debug report(results)# output reportdef report(results): for key, result in sorted(results.items()): group, unit = key.split(';') print('&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'.format( result.count, group, result.average, unit))data = &#123; 'girls;kg': [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5], 'girls;m': [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43], 'boys;kg': [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3], 'boys;m': [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],&#125;if __name__ == '__main__': main(data) averager是子生成器 main函数中的客户代码发送的各个值绑定到这里的term变量上 至关重要的终止条件，如果没有终止条件，使用yield from调用这个协程的生成器会永远阻塞 返回的Result会成为grouper函数中yield from表达式的值 grouper是委派生成器 这个循环每次迭代时会新建一个averager实例，每个实例都是作为协程使用的生成器对象 grouper发送的每个值都会经由yield from处理，通过管道传给averager实例。grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值。averager实例运行完毕后，返回的值绑定到result[key]上。while循环会不断创建averager实例，处理更多的值 main函数是客户端代码，即是调用方 group是调用grouper函数得到的生成器对象，传给grouper函数的第一个参数是results，用于收集结果，第二个参数是某键。group作为协程使用。 预激group协程 把各个value传给grouper。传入的值最终到达averager函数中term = yield那一行 把None传入grouper，导致当前的averager实例终止，也让grouper继续运行，再创建一个averager实例，处理下一组值 yield from的意义yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码以及各种.close()和.throw()方法。 使用future处理并发 并发：交替做不同事的能力 并行：同时做不同事的能力 网络下载的三种风格CPU密集型任务 vs IO密集型任务 为了高效处理网络IO，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络响应之前做些其他的事。 使用依序下载1234567891011121314151617181920212223242526272829303132333435363738394041import osimport timeimport sysimport requests # &lt;1&gt;POP20_CC = ('CN IN US ID BR PK NG BD RU JP ' 'MX PH VN ET EG DE IR TR CD FR').split() # &lt;2&gt;BASE_URL = 'http://flupy.org/data/flags' # &lt;3&gt;DEST_DIR = 'downloads/' # &lt;4&gt;def save_flag(img, filename): # &lt;5&gt; path = os.path.join(DEST_DIR, filename) with open(path, 'wb') as fp: fp.write(img)def get_flag(cc): # &lt;6&gt; url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(BASE_URL, cc=cc.lower()) resp = requests.get(url) return resp.contentdef show(text): # &lt;7&gt; print(text, end=' ') sys.stdout.flush()def download_many(cc_list): # &lt;8&gt; for cc in sorted(cc_list): # &lt;9&gt; image = get_flag(cc) show(cc) save_flag(image, cc.lower() + '.gif') return len(cc_list)def main(download_many): # &lt;10&gt; t0 = time.time() count = download_many(POP20_CC) elapsed = time.time() - t0 msg = '\\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s' print(msg.format(count, elapsed))if __name__ == '__main__': main(download_many) # &lt;11&gt; 使用concurrent.futures模块下载1234567891011121314151617181920from concurrent import futuresfrom flags import save_flag, get_flag, show, main MAX_WORKERS = 20 # 1def download_one(cc): image = get_flag(cc) show(cc) save_flag(image, cc.lower() + '.gif') return ccdef download_many(cc_list): workers = min(MAX_WORKERS, len(cc_list)) # 2 with futures.ThreadPoolExecutor(workers) as executor: # 3 res = executor.map(download_one, sorted(cc_list)) # 4 return len(list(res)) # 5if __name__ == '__main__': main(download_many) 设定ThreadPoolEXecutor类最多使用几个线程 设定工作的线程数量，使用允许的最大值MAX_WORKERS与要处理的数量之间较小的那个值，以免创建多余的线程 使用工作的线程数实例化ThreadPoolExecutor，executor.__exit__方法会用executor.shutdown(wait=True)方法，它会在所有线程都执行完毕钱阻塞线程 map方法的作用与内置的map函数类似，不过download_one函数会在多个线程中并发调用；map方法返回一个生成器，因此可以迭代，获取各个返回的值 Future在哪里Future类的实例表示：可能已经完成或者尚未完成的延迟计算。它封装待完成的操作，可以放入队列，完成的状态可以查询，得到记过后可以获取结果。 123456789101112131415161718def download_many(cc_list): cc_list = cc_list[:5] with futures.ThreadPoolExecutor(max_workers=3) as executor: to_do = [] for cc in sorted(cc_list): future = executor.submit(download_one, cc) # 1 to_do.append(future) # 2 msg = 'Scheduled for &#123;&#125;: &#123;&#125;' print(msg.format(cc, future)) results = [] for future in futures.as_completed(to_do): # 3 res = future.result() # 4 msg = '&#123;&#125; result: &#123;!r&#125;' print(msg.format(future, res)) results.append(res) return len(results) executor.submit方法排定可调用对象的执行时间，然后返回一个Future，表示这个待执行操作 存储各个Future，后面传递个as_completed函数 as_completed函数在Future运行结束后产出Future 获取该Futrue的结果 阻塞型IO和GILCPython解释器不是线程安全的，因此有全程解释器锁GIL，一次只允许使用一个线程执行Python字节码。 标准库中所有执行阻塞型IO操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着在Python语言层次可以使用多线程，而IO密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型IO函数会释放GIL，再运行一个线程。 使用concurrent.futures模块启动进程concurrent.futures这个模块实现的是真正的并行计算，因为它使用ProcessPoolExecutor类把工作分配给多个Python进程处理，因此如果需要做CPU密集处理，使用这个模块能够绕开GIL，利用所有可用的CPU核心。 实验Executor.map方法1234567891011121314151617181920212223242526from time import sleep, strftimefrom concurrent import futuresdef display(*args): print(strftime('[%H:%M:%S]'), end=' ') print(*args)def loiter(n): msg = '&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...' display(msg.format('\\t'*n, n, n)) sleep(n) msg = '&#123;&#125;loiter(&#123;&#125;): done.' display(msg.format('\\t'*n, n)) return n * 10 def main(): display('Script starting.') executor = futures.ThreadPoolExecutor(max_workers=3) # 1 results = executor.map(loiter, range(5)) # 2 display('results:', results) display('Waiting for individual results:') for i, result in enumerate(results): # 3 display('result &#123;&#125;: &#123;&#125;'.format(i, result))main() 创建ThreadPoolExecutor实例，有3个线程 把五个任务提交给executor，因为只有3个线程，所以只有3个任务会立即开始：loiter(0)、loiter(1)和loiter(2)，这是非阻塞调用 for循环中的enumerate函数会隐式调用next(results)，这个函数又会在内部表示第一个任务loiter(0)的_f期物上调用_f.result()方法。result方法会阻塞，直到期物运行结束，因此这个循环每次迭代时都要等待下一个结果做好准备。 线程和多进程的替代方案 futures.ThreadPoolExecutor类可以创建多线程，但是不够灵活可能要使用threading模块来自行制定方案，比如说使用queue模块创建线程安全的队列，在线程之间传递数据 futures.ProcessPoolExecutor类可以创建多进程，但是不够灵活可能要使用multiprocessing模块代来自行定制方案，可以解决协作进程之间传递数据的问题 使用asyncio包处理并发 阻塞与非阻塞：如果不能立即获得结果，那么是否等待？ 同步与异步：是否需要调用者来通知结果 如何解决CPU高速执行能力和IO设备低速执行能力之间的矛盾？ 同步IO：等待IO操作完成，才能进行下一步操作 同步IO模型下，主线程只能被挂起。使用多线程和多进程方法解决同步IO的并发问题，但是系统不能无上限的增加线程。由于系统切换线程的开销也很大，所以一旦线程数量过多，CPU的时间就话在线程切换上了，真正运行代码的时间就少了，结果导致性能下降。 异步IO：不等待IO结果，去干别的事。当IO返回结果时再通知CPU处理。 异步模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，异步IO将大大提升系统的多任务处理能力。 线程与协程对比 进程：一个程序在一个数据集中的一次动态执行过程，它是操作系统进行资源分配和调度的一个独立单位。 进程一般由程序、数据集、进程控制块三部分组成。我么编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 进程占据独立内存，不同进程通过进程间通信来通信。创建、撤销和切换的开销比较大，但是相对稳定安全。 线程：进程的一个实体，是操作系统调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，如程序计数器、一组寄存器和栈，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 协程：一种用户态的轻量级线程，它的调度完全由用户在代码里控制，不关操作系统什么事。 协程的执行效率非常高。因为子程序切换不是线程切换而由程序自身控制。因此没有线程切换的开销，和多线程比，线程数量越多协程性能就越明显。协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。 1234567891011121314151617181920212223242526272829303132333435363738import threadingimport itertoolsimport timeimport sysdef spin(msg, done): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\\\'): # 1 status = char + ' ' + msg write(status) flush() write('\\x08' * len(status)) # 2 if done.wait(.1): break write(' ' * len(status) + '\\x08' * len(status)) def slow_function(): # pretend waiting a long time for I/O time.sleep(3) return 42def supervisor(): # 3 done = threading.Event() # 4 spinner = threading.Thread(target=spin, args=('thinking!', done)) print('spinner object:', spinner) spinner.start() # 5 result = slow_function() # 6 done.set() spinner.join() return resultdef main(): result = supervisor() print('Answer:', result)if __name__ == '__main__': main() 这是个无限循环，因为itertools.cycle函数会从指定的序列中反复不断的生成元素 这是显示文本式样动画的诀窍所在，使用退格符\\x08把光标移回来 这个函数设置从属线程，显示线程对象，运行耗时的计算，最后杀死线程 定义事件done = threading.Event()，阻塞事件线程done.wait()如果事件标志为True则不阻塞若有参数为阻塞时间，继续事件线程done.set()设置时间标志位True，结束事件线程done.clear()设置事件标志为False spinner.start()启动从属线程，spinner.join()等待线程结束 运行slow_function函数，阻塞主线程，同时从属线程以动画形式显示旋转指针 12345678910111213141516171819202122232425262728293031323334353637383940import asyncioimport itertoolsimport sys@asyncio.coroutine # &lt;1&gt;def spin(msg): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\\\'): status = char + ' ' + msg write(status) flush() write('\\x08' * len(status)) try: yield from asyncio.sleep(.1) # &lt;2&gt; except asyncio.CancelledError: # &lt;3&gt; break write(' ' * len(status) + '\\x08' * len(status))@asyncio.coroutinedef slow_function(): # &lt;4&gt; # pretend waiting a long time for I/O yield from asyncio.sleep(3) return 42@asyncio.coroutinedef supervisor(): # &lt;5&gt; spinner = asyncio.async(spin('thinking!')) # &lt;6&gt; print('spinner object:', spinner) result = yield from slow_function() # &lt;7&gt; spinner.cancel() # &lt;8&gt; return resultdef main(): loop = asyncio.get_event_loop() # &lt;9&gt; result = loop.run_until_complete(supervisor()) # &lt;10&gt; loop.close() print('Answer:', result)if __name__ == '__main__': main() 使用@asyncio.coroutine装饰器不是强制要求，但是强烈建议这么做，因为这样能在一众普通函数中把协程凸显出来，也有助于调试。如果还没从中产出值，协程就被垃圾回收了，那就可以发出警告。这个装饰器不会预激协程。 使用yield from asyncio.sleep(.1)代替time.sleep(.1)，这样的休眠不会阻塞事件循环 如果spin函数苏醒后抛出asyncio.CancelledError异常，其原因是发出了取消请求，因此退出了循环 现在slow_function函数是协程了，在用休眠假装进行IO操作时，使用yield from继续执行事件循环，yield from asyncio.sleep(3)表达式把控制权交给主循环，在休眠结束后恢复这个协程 现在supervisor函数也是协程了，因此可以使用yield from驱动slow_function函数 asyncio.async()函数排定spin协程的运行时间，使用一个Task对象包装spin协程并立即返回 驱动slow_function()函数，结束后获取返回值的同时，事件循环继续运行，因为slow_function函数最后使用yield from asynico.sleep(3)表达式把控制权交回给主循环 Task对象可以取消，取消后会在协程当前暂停的yield处抛出asynico.CancelledError异常。协程可以捕获这个异常，也可以延迟取消，甚至拒绝取消 获取事件循环的引用。所谓事件循环，程序开启一个无限的循环，程序员会把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数。 驱动supervisor协程，让它运行完毕。这个协程的返回值是这次调用的返回值 asynico.Future：故意不阻塞 asynico.Future类的.result()方法没有参数，不能指定超时时间。此外，如果调用.result()方法时期物还没运行完毕，那么.result()方法不会阻塞去等待结果，而是抛出asyncio.InvalidStateError异常 使用yield from处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在asyncio包中，yield from的作用是把控制权还给事件循环 一般情况下，asynico.Future对象由yield from驱动，而不是靠调用.done()、.add_done_callback()和.result()方法驱动 从期物、任务和协程中产出在asyncio包中，期物和协程关系紧密，因为可以使用yield from从asyncio.Future对象中产出结果。通过如res = yield from foo()可以互换协程和期物。 为了执行这些操作，必须排定协程的运行时间，然后使用asyncio.Task对象包装协程。对协程来说，获取Task对象有两种方式： asynico.async(coro_or_future, *, loop=None) 这个函数统一了协程和期物，第一个参数可以是其中的任意一个。如果是协程，那么async函数会调用loop.create_task()方法创建Task对象。loop=关键字参数是可选的，用于传入事件循环。如果没有传入，那么async函数会通过调用asyncio.get_event_loop()函数获取循环对象。 BaseEventLoop.create_task(coro) 这个方法排定协程的执行时间，返回一个asynico.Task对象。 使用asyncio和aiohttp包下载 编写的协程链条始终通过把最外层委派生成器传给asynico包中的某个函数，如loop.run_until_complete()驱动 编写的协程链条最终通过yield from把职责委托给asyncio包中的某个协程函数或协程方法，如asyncio.sleep()和aiohttp.request() 概括起来就是：使用asyncio包时，我们编写的异步代码包含由asynico本身驱动的协程即委派生成器，而生成器最终把职责委托给asyncio包或第三方库中的协程。这种处理方式相当于架起了管道，让asynico事件循环驱动执行低层异步IO操作的库函数。 12345678910111213141516171819202122232425262728import asyncioimport aiohttp from flags import BASE_URL, save_flag, show, main @asyncio.coroutine def get_flag(cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(BASE_URL, cc=cc.lower()) resp = yield from aiohttp.request('GET', url) # 1 image = yield from resp.read() # 2 return image@asyncio.coroutinedef download_one(cc): # 3 image = yield from get_flag(cc) show(cc) save_flag(image, cc.lower() + '.gif') return ccdef download_many(cc_list): loop = asyncio.get_event_loop() # 4 to_do = [download_one(cc) for cc in sorted(cc_list)] wait_coro = asyncio.wait(to_do) # 5 res, _ = loop.run_until_complete(wait_coro) # 6 loop.close() return len(res)if __name__ == '__main__': main(download_many) 非阻塞的操作通过协程实现，客户代码通过yield from把职责委托给协程，以便异步运行协程 读取相应内容是一项异步操作 download_one函数也必须是协程，因为用到了yield from 获取事件循环底层实现的引用 wait是一个协程，等待给它的所有协程运行完毕后结束，把各个协程包装进一个Task对象 执行事件循环，直到wait_coro运行结束，事件循环运行的过程中，这个脚本会在这里阻塞。 避免阻塞型调用有两种方法能避免阻塞型调用中止整个应用程序的进程： 在单独的线程中运行个阻塞型操作，然后启用多线程，消耗的内存比较大 把每个阻塞型操作转换成非阻塞的异步调用使用 改进asycio下载脚本使用asyncio.as_completed函数原版把一个协程列表传给asyncio.wait函数，经由loop.run_until_complete方法驱动，全部协程运行结束后才能返回结果。可是为了更新进度条，各个协程运行结束后就要立即获取结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import asyncioimport collectionsimport contextlibimport aiohttpfrom aiohttp import webimport tqdmfrom flags2_common import main, HTTPStatus, Result, save_flag# default set low to avoid errors from remote site, such as# 503 - Service Temporarily UnavailableDEFAULT_CONCUR_REQ = 5MAX_CONCUR_REQ = 1000class FetchError(Exception): # &lt;1&gt; def __init__(self, country_code): self.country_code = country_code@asyncio.coroutinedef get_flag(base_url, cc): # &lt;2&gt; url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(base_url, cc=cc.lower()) resp = yield from aiohttp.request('GET', url) with contextlib.closing(resp): if resp.status == 200: image = yield from resp.read() return image elif resp.status == 404: raise web.HTTPNotFound() else: raise aiohttp.HttpProcessingError( code=resp.status, message=resp.reason, headers=resp.headers)@asyncio.coroutinedef download_one(cc, base_url, semaphore, verbose): # &lt;3&gt; try: with (yield from semaphore): # &lt;4&gt; image = yield from get_flag(base_url, cc) # &lt;5&gt; except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc else: save_flag(image, cc.lower() + '.gif') status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc)@asyncio.coroutinedef downloader_coro(cc_list, base_url, verbose, concur_req): # 6 counter = collections.Counter() semaphore = asyncio.Semaphore(concur_req) # 7 to_do = [download_one(cc, base_url, semaphore, verbose) for cc in sorted(cc_list)] to_do_iter = asyncio.as_completed(to_do) # 8 if not verbose: to_do_iter = tqdm.tqdm(to_do_iter, total=len(cc_list)) for future in to_do_iter: try: res = yield from future except FetchError as exc: country_code = exc.country_code try: error_msg = exc.__cause__.args[0] except IndexError: error_msg = exc.__cause__.__class__.__name__ if verbose and error_msg: msg = '*** Error for &#123;&#125;: &#123;&#125;' print(msg.format(country_code, error_msg)) status = HTTPStatus.error else: status = res.status counter[status] += 1 return counter def download_many(cc_list, base_url, verbose, concur_req): loop = asyncio.get_event_loop() coro = downloader_coro(cc_list, base_url, verbose, concur_req) counts = loop.run_until_complete(coro) # 9 loop.close() return countsif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ) 自定义异常用于包装其他HTTP或网络异常，并获取country_code，以便报告错误 get_flag协程有三种返回结果：返回下载得到的图像；HTTP响应码为404时，抛出web.HTTPNotFound异常；返回其他HTTP状态码时，抛出aiohttp.HttpProcessingError异常。 semaphore参数是asyncio.Semaphore类的实例，Semaphore类是同步配置，用于限制并发请求数 在yield from表达式中把semaphore当成上下文管理器使用，防止阻塞整个系统，如果semaphore计数器的值是所允许的最大值，只有这个协程会阻塞。 退出这个with语句后，semaphore计数器的值会递减，解除阻塞可能在等待同一个semaphore对象的其他协程实例 这个协程的参数与download_many函数一致，但是不能直接调用。因为只要函数中yield from，函数就会变成协程，协程是不能直接调用的。 创建一个asyncio.Semaphore实例，最多允许激活concur_req个使用这个计数器的协程 获取一个迭代器，这个迭代器会在期物运行结束后返回期物 download_many函数只是实例化downloader_coro协程，然后通过run_until_complete方法把它传给事件循环 使用Executor对象，防止阻塞事件循环访问本地文件系统可能也会阻塞 123456789101112131415161718192021@asyncio.coroutinedef download_one(cc, base_url, semaphore, verbose): try: with (yield from semaphore): image = yield from get_flag(base_url, cc) except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc else: loop = asyncio.get_event_loop() # &lt;1&gt; loop.run_in_executor(None, # &lt;2&gt; save_flag, image, cc.lower() + '.gif') # &lt;3&gt; status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc) 获取事件循环对象的引用 run_in_executor方法的第一个参数是Executor实例，如果设置为None，使用事件循环默认ThreadPoolExecutor实例 余下参数是可调用的对象，以及可调用对象的位置参数 从回调到期物和协程如果需要协调异步请求，而不只是发起完全独立的请求，协调较之回调的好处会变得显而易见。避免陷入，回调地狱。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import asyncioimport collectionsimport aiohttpfrom aiohttp import webimport tqdmfrom flags2_common import main, HTTPStatus, Result, save_flag# default set low to avoid errors from remote site, such as# 503 - Service Temporarily UnavailableDEFAULT_CONCUR_REQ = 5MAX_CONCUR_REQ = 1000class FetchError(Exception): def __init__(self, country_code): self.country_code = country_code@asyncio.coroutinedef http_get(url): res = yield from aiohttp.request('GET', url) if res.status == 200: ctype = res.headers.get('Content-type', '').lower() if 'json' in ctype or url.endswith('json'): data = yield from res.json() # &lt;1&gt; else: data = yield from res.read() # &lt;2&gt; return data elif res.status == 404: raise web.HTTPNotFound() else: raise aiohttp.errors.HttpProcessingError( code=res.status, message=res.reason, headers=res.headers)@asyncio.coroutinedef get_country(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/metadata.json'.format(base_url, cc=cc.lower()) metadata = yield from http_get(url) # &lt;3&gt; return metadata['country']@asyncio.coroutinedef get_flag(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(base_url, cc=cc.lower()) return (yield from http_get(url)) # &lt;4&gt;@asyncio.coroutinedef download_one(cc, base_url, semaphore, verbose): try: with (yield from semaphore): # &lt;5&gt; image = yield from get_flag(base_url, cc) with (yield from semaphore): country = yield from get_country(base_url, cc) except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc else: country = country.replace(' ', '_') filename = '&#123;&#125;-&#123;&#125;.gif'.format(country, cc) loop = asyncio.get_event_loop() loop.run_in_executor(None, save_flag, image, filename) status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc)@asyncio.coroutinedef downloader_coro(cc_list, base_url, verbose, concur_req): counter = collections.Counter() semaphore = asyncio.Semaphore(concur_req) to_do = [download_one(cc, base_url, semaphore, verbose) for cc in sorted(cc_list)] to_do_iter = asyncio.as_completed(to_do) if not verbose: to_do_iter = tqdm.tqdm(to_do_iter, total=len(cc_list)) for future in to_do_iter: try: res = yield from future except FetchError as exc: country_code = exc.country_code try: error_msg = exc.__cause__.args[0] except IndexError: error_msg = exc.__cause__.__class__.__name__ if verbose and error_msg: msg = '*** Error for &#123;&#125;: &#123;&#125;' print(msg.format(country_code, error_msg)) status = HTTPStatus.error else: status = res.status counter[status] += 1 return counterdef download_many(cc_list, base_url, verbose, concur_req): loop = asyncio.get_event_loop() coro = downloader_coro(cc_list, base_url, verbose, concur_req) counts = loop.run_until_complete(coro) loop.close() return countsif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)","tags":[{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"}]},{"title":"Fluent Python (1)：数据结构","date":"2018-05-30T06:55:00.392Z","path":"2018/05/30/Python-FlunetPython-data/","text":"数据模型纸牌的数据模型1234567891011121314151617181920import collectionsCard = collections.namedtuple('Card', ['rank', 'suit']) # 1class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') # 2 suits = 'spades diamonds clubs hearts'.split() def __init__(self): # 3 self._cards = [Card(rank, suit) for suit in self.suits # 4 for rank in self.ranks] def __len__(self): # 5 return len(self._cards) def __getitem__(self, position): # 6 return self._cards[position]if __name__ == '__main__': deck = FrenchDeck() collections.namedtuple：用以构建只有少数属性但是没有方法的对象，如数据库条目 类属型，类和实例皆可访问 __init__：创建实例时的初始化 实例属性 self.cards：公共属性，在类和子类中使用，实例化后可以访问 self._cards：单下划线，表示私有（保护类型）类型（方法，属性），在类和子类中使用，假装不给实例化后访问 self.__cards：双下划线，表示私有类型，子类不可访问，硬要访问的话_FrenchDeck__cards __len__：特殊方法，len(deck) == deck.__len__() __getitem__：特殊方法，deck[1] == deck__getitem__(1) 向量的数据模型1234567891011121314151617181920212223242526272829from math import hypotclass Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): # 1 return 'Vector(%r, %r)' % (self.x, self.y) # 2 def __abs__(self): return hypot(self.x, self.y) def __bool__(self): # 3 return bool(abs(self)) def __add__(self, other): # 4 x = self.x + other.x y = self.y + other.y return Vector(x, y) def __mul__(self, scalar): return Vector(self.x * scalar, self.y * scalar)if __name__ == '__main__': a = Vector(4, 9) b = Vector(4, 6) print(a+b) __repr__ vs __str__ __repr__：字符串表示形式，所返回的字符串准确无歧义，打印一个对象时用特定字符串显示，如果没有实现这个方法，打印时得到的字符串可能是&lt;Vector object at 0x10e100070&gt; __str__：使用str()函数或print函数时被调用，如果对象没有这个方法，解释器会用__repr__代替，所以优先定义__repr__方法 %r vs %s %r：使用repr()函数格式化对象 %s：使用str()函数格式化对象 &quot;i love %s&quot;%&#39;you&#39; != &quot;i love %r&quot;%&#39;you&#39; __bool__：自定义布尔值，if Vector(0,0) &lt;=&gt; if Vector(0,0)__bool__() __add__, __mul__：自定义加法，自定义乘法 序列构成的数组内置序列类型概览序列，故名思义，有顺序的一组数据。序列无非就是：迭代、切片、排序、拼接 按存放的数据类型分类 容器序列(可存放不同类型的数据)：list、tuple、collections.deque 扁平序列(只能存放一种类型)：str、bytes、bytearray、memeryview、array.array 按能否被修改来分类 可变序列：list、bytearray、array.array、collections.deque、memeryview 不可变序列：tuple、str、bytes 列表推导和生成器表达式列表解析式1234567891011symbols = '$¢£¥€¤'codes = [ord(symbol) for symbol in symbol] # 1symbols = '$¢£¥€¤'beyond_ascii = [ord(s) for s in symbols if ord(s) &gt; 127]beyond_ascii = list(filter(lambda c: c &gt; 127, map(ord, symbols) # 2 colors = ['black', 'white']sizes = ['S', 'M', 'L']tshirts = [(color, size) for color in colors for size in sizes] # 3tshirts = [(color, size) for size in sizes for color in colors] 列表解析式的可读性好，太复杂时也不要滥用 filter和map合起来能做的事，列表解析式也能做，而且可读性更好 列表解析式可以生成两个或两个以上的可迭代类型的笛卡尔积 生成器表达式12345678910symbols = '$¢£¥€¤'tuple(ord(symbol) for symbol in symbols) # 1import arrayarray.array('I', (ord(symbol) for symbol in symbols)) # 2 colors = ['black', 'white']sizes = ['S', 'M', 'L']for tshirt in ('%s %s'%(c, s) for c in colors for s in sizes): # 3 print(tshirt) 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要用括号围起来 array的构造方法需要两个参数，括号是必须的 生成器表达式会逐个产出元素，避免额外的内存占用 元组元组和记录123456traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]for passport in sorted(traveler_ids): print('%s/%s' % passport) # 1 for contry, _ in traveler_id: # 2 print(country) %格式化运算符能被匹配到对应的元组元素上 for循环可以分别提取元组的元素，也作拆包，因为第二个元素对我们没什么用，所以赋值给占位符_ 元组拆包123456b, a = a, b # 1t = (20, 8) # 2divmod(*t)a, *body, c, d = range(5) #3 优雅的不用中间变量交换两个变量的值 *运算符把一个可迭代对象拆开作为函数的参数 用*来处理剩下的元素 具名元组12345678from collections import namedtupleCity = namedtuple('City', 'name country population coordinates') # 1tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) # 2City._fields # 3delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889)) delhi = City._make(delhi_data) # 4delhi._asdict() # 5 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字，后者形式可以是&#39;name country population coordinates&#39;或者是[&#39;name&#39;, &#39;counry&#39;, &#39;population&#39;, &#39;coordinates&#39;] 存放在对应字段的数据要以一串参数的形式传入到构造函数中 _fields属性是一个包含这个类所有字段名称的元组 City._make(delhi_data) == City(*delhi_data) _asdict()把具名元组以collections.OrderedDict的形式返回，把元组里的信息友好的呈现出来 切片1234567891011s = 'bicycle' # 1s[::3]s[::-1]s[::-2]s[2::3]l = list(range(10)) # 2l[2::5] = [20, 30]del l[5:7]l[3::2] =[11, 22]l[2:5] = [100] seq[start:stop:step]，start无值时从头开始，stop无值时至尾结束，step为负时反向取值 如果赋值对象是一个切片，那么赋值语句的右侧必须是可迭代对象，即使只有一个单独的值，也要转换为可迭代序列 使用+和*拼接序列12345678l = [1, 2, 3] # 1l * 55 * &apos;abcd&apos;board = [[&apos;_&apos;] * 3 for i in range(3)] # 2board[1][2] = &apos;X&apos;wrong_board = [[&apos;_&apos;] *3] * 3wrong_board[1][2] = &apos;X&apos; Python程序员会默认序列是支持+和*操作的 board != wrong_board，引用传递和值传递的不同，可变对象都是引用传递，原地址没变 序列的增量赋值1234&gt;&gt;&gt; t = (1, 2, [30, 40])&gt;&gt;&gt; t[2] += [50, 60]Traceback (most recent call last):File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment&gt;&gt;&gt; t(1, 2, [30, 40, 50, 60]) 不要把可变对象放在元祖里 增量赋值不是一个原子操作，虽然抛出了异常，但是还是完成了操作 通过dis.dis(&#39;t[2] += [50, 60]&#39;)可以查看Python的字节码，帮助我们了解代码背后的运行机制 list.sort方法和内置函数sorted1234fruits = ['grape', 'raspberry', 'apple', 'banana']sorted(fruits)sorted(fruits, key=len, reverse=True) # 1fruits.sort() # 2 新建一个按长度降序排序的结果 对原列表就地排序，返回值为None会被控制台忽略 用bisect来管理已排序的序列用bisect来搜索12345678910111213141516171819202122232425import bisectimport sysHAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]ROW_FMT = '&#123;0:2d&#125; @ &#123;1:2d&#125; &#123;2&#125;&#123;0:&lt;2d&#125;'def demo(bisect_fn): for needle in reversed(NEEDLES): position = bisect_fn(HAYSTACK, needle) # &lt;1&gt; # print (position) offset = position * ' |' # &lt;2&gt; print(ROW_FMT.format(needle, position, offset)) # &lt;3&gt;if __name__ == '__main__': if sys.argv[-1] == 'left': # &lt;4&gt; bisect_fn = bisect.bisect_left else: bisect_fn = bisect.bisect print('DEMO:', bisect_fn.__name__) # &lt;5&gt; print('haystack -&gt;', ' '.join('%2d' % n for n in HAYSTACK)) demo(bisect_fn) 用bisect.insort插入新元素123456789101112import bisectimport randomSIZE = 7random.seed(1729)my_list = []for i in range(SIZE): new_item = random.randrange(SIZE*2) bisect.insort(my_list, new_item) print('%2d -&gt;' % new_item, my_list) 当列表不是首选时数组12345678910from array import arrayfrom random import randomfloats = array('d', (random() for i in range(10**7))) # 1fp = open('floats.bin', 'wb')floats.tofile(fp) # 2fp.close()fp = open('floats.bin', 'rb')floats.fromfile(fp, 10**7) # 3fp.close() 利用一个可迭代对象建立一个双精度浮点数组，类型码是d，如果我们只需要一个包含数字的列表，那么array.array比list更高效 array.tofile把数组存入文件，比写入文本文件快7倍 array.fromfile把数组从文件读取出来，比从文本文件读取出来快60倍 内存视图NumPy和SciPy队列字典和集合泛映射类型1234567891011my_dict = &#123;&#125;isinstance(my_dict, abc.Mapping) # 1tl = (1, 2, [30, 40])hash(tl) # 2a = dict(one=1, two=2, three=3) # 3b = &#123;'one': 1, 'two': 2, 'three': 3&#125;c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))d = dict([('two', 2), ('one', 1), ('three', 3)])e = dict(&#123;'three': 3, 'one': 1, 'two': 2&#125;) collections.adc模块中有Mapping和MutableMapping这两个抽象基类，为dict和其他类似的类型定义形式接口 不可变对象都是可散列对象，就是说可变对象不能作为字典的键，如果元组中有可变对象就例外 a == b == c == d == e 字典推导123456789101112131415DIAL_CODES = [ (86, 'China'), (91, 'India'), (1, 'United States'), (62, 'Indonesia'), (55, 'Brazil'), (92, 'Pakistan'), (880, 'Bangladesh'), (234, 'Nigeria'), (7, 'Russia'), (81, 'Japan'), ]country_code = &#123;country: code for code, country in DIAL_CODES&#125;&#123;code: country.upper() for country, code in country_code.items() if code &lt; 66&#125; 常见映射方法update12345a = &#123;&#125;m = &#123;'b': 1&#125; a.update(m) # 1m = &#123;'b': 3&#125;a.update(**m) # 2 没则插入 有则更新 setdefault1234567891011121314151617import sysimport reWORD_RE = re.compile('\\w+')index = &#123;&#125;with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start()+1 location = (line_no, column_no) index.setdefault(word, []).append(location) # 1# print in alphabetical orderfor word in sorted(index, key=str.upper): print(word, index[word]) 获取单词出现情况的列表。如果单词不存在，单词做键，空列表做值放进字典；如果单词存在，把值添加到单词对用的列表 映射的弹性键查询defaultdict123456789101112131415161718import sysimport reimport collectionsWORD_RE = re.compile('\\w+')index = collections.defaultdict(list) # 1with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start()+1 location = (line_no, column_no) index[word].append(location) # 2# print in alphabetical orderfor word in sorted(index, key=str.upper): print(word, index[word]) 把list构造方法作为default_factory来构建一个defaultdict 如果index并没有word的记录，那么default_factory会被调用，为查询不到的键创造一个值，这个值在这里是空列表 __missing__123456789101112131415class StrKeyDict0(dict): def __missing__(self, key): # 1 if isinstance(key, str): raise KeyError(key) return self[str(key)] def get(self, key, default=None): try: return self[key] except KeyError: return default def __contains__(self, key): # 2 return key in self.keys() or str(key) in self.keys() __missing__在映射类型找不到键时调用，通过isinstance(key, str)测试，避免代码陷入无限递归 dict.__contains__(key) == key in dict，直接在self.keys()里查询，避免递归调用 字典的变种collections.OrderedDictcollections.ChainMapcollections.Countercollections.UserDict子类化UserDict1234567891011121314import collectionsclass StrKeyDict(collections.UserDict): # 1 def __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)] def __contains__(self, key): return str(key) in self.data def __setitem__(self, key, item): self.data[str(key)] = item # 2 更倾向于从UserDict而不是dict的子类继承的主要原因是，后者会在某些方法的实现上走一些捷径，导致在子类中不得不重写这些方法 __setitem__会把所有的键都转换成字符串 不可变映射类型12345678910111213&gt;&gt;&gt; from types import MappingProxyType&gt;&gt;&gt; d = &#123;1:'A'&#125;&gt;&gt;&gt; d_proxy = MappingProxyType(d)&gt;&gt;&gt; d_proxymappingproxy(&#123;1: 'A'&#125;)&gt;&gt;&gt; d_proxy[1] 'A'&gt;&gt;&gt; d_proxy[2] = 'x'Traceback (most recent call last):File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'mappingproxy' object does not support item assignment&gt;&gt;&gt; d[2] = 'B'&gt;&gt;&gt; d_proxy mappingproxy(&#123;1: 'A', 2: 'B'&#125;)&gt;&gt;&gt; d_proxy[2]'B' 集合论1234567l = ['spam', 'spam', 'eggs', 'spam']set(l) # 1found = len(needles &amp; haystack) # 2from unicodedata import name&#123;chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')&#125; # 3 集合去重 集合运算 集合解析式 dict和set的背后dict和set的效率不管查询有多少个元素的字典和集合，所耗费的时间都能忽略不计。而列表随元素的增多，查询时间越长。 字典中的散列表 散列表 Python用散列表来实现dict类型，散列表其实是一个稀疏数组，总有空白元素的数组成为稀疏数组。散列表的结构单元被称为表元，在dict的散列表中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，一个是对值的应用，因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。因为Python会设法保证大概有三分之一的表元是空的，所以在快要达到这个阈值时，原有散列表会被复制到一个更大的空间。 散列值和相等性 如果两个对象在比较的时候相等，那么它们的散列值必须相等，否则散列表就不能正常运行了。为了让散列值能够胜任散列表索引的角色，它们必须在索引空间中尽量分散开来。这意味着在最理想的状况下，越是相似但不想等的对象，它们散列值的差别应该越大。 散列表算法 dict的实现及其导致的结果 键必须是可散列的 支持hash()函数，并且通过__hash()__方法所得到的散列值是不变的 支持通过__eq__()方法来检测相等性 若a == b为真，则hash(a) == hash(b)也为真 字典在内存上开销巨大 由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。 键查询很快 dict的实现是典型的空间换时间：字典类型有着巨大的内存开销，但它们提供了无视数据量大小的快速访问——只要字典能被装在内存里。 键的次序取决于添加顺序 往字典里添加新键可能会改变已有键的顺序 无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。 set的实现以及导致的结果 集合里的元素必须是可散列的 集合很消耗内存 可以很高效地判断元素是否存在于某个集合 元素的次序取决于被添加到集合里的次序 往集合里添加元素，可能会改变集合里已有元素的次序 文本和字节序列字符问题1234s = 'xiehailian'b = s.encode('utf8') # 1b.decode('utf8') # 2 使用UTF-8把str对象编码成bytes对象 使用UTF-8把bytes对象解码成str对象 字节概要1234567cafe = bytes('cafe', encoding='utf_8') # 1cafe[0] # 2cafe[:1] # 3cafe_arr = bytearray(cafe) cafe_arr # 4cafe_arr[-1:] # 5 bytes对象可以从str对象使用给定的编码构建 bytes的各个元素range(256)内的整数 bytes对象的切片还是bytes对象，即使是只有一个字节的切片 bytearray对象没有字面量句法，而是以bytearray()和字节序列字面量参数的形式显示 bytearray对象的切片还是bytearray对象 123456789101112import arraynumbers = array.array('h', [-2, -1, 0, 1, 2])octets = bytes(numbers) # 1import structfmt = '&lt;3s3sHH'with open('filter.gif', 'rb') as fp: img = memoryview(fp.read()) # 2header = img[:10] bytes(header) struct.unpack(fmt, header) # 3del header 将数组保存为字节序列的副本 使用内存中的文件内容创建一个memoryview对象，memoryview类不用于创建或存储字节序列，而是共享内存无需复制字节序列 拆包memoryview对象，得到一个元祖 基本的编解码器 GBK UTF-8 了解编解码问题处理UnicodeEncodeError1234567891011121314151617181920&gt;&gt;&gt;city = 'São Paulo'&gt;&gt;&gt; city.encode('utf_8') # 1b'S\\xc3\\xa3o Paulo'&gt;&gt;&gt; city.encode('utf_16')b'\\xff\\xfeS\\x00\\xe3\\x00o\\x00 \\x00P\\x00a\\x00u\\x00l\\x00o\\x00'&gt;&gt;&gt; city.encode('iso8859_1') b'S\\xe3o Paulo'&gt;&gt;&gt; city.encode('cp437') Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"/.../lib/python3.4/encodings/cp437.py\", line 12, in encode return codecs.charmap_encode(input,errors,encoding_map)UnicodeEncodeError: 'charmap' codec can't encode character '\\xe3' in position 1: character maps to &lt;undefined&gt; &gt;&gt;&gt; city.encode('cp437', errors='ignore') b'So Paulo'&gt;&gt;&gt; city.encode('cp437', errors='replace') b'S?o Paulo'&gt;&gt;&gt; city.encode('cp437', errors='xmlcharrefreplace') b'São Paul utf_?，iso8859_1能处理这个字符串，而cp437不能处理这个字符串 error=&#39;ignore&#39;将悄无声息地跳过无法编码的字符：这样做不太好 编码时指定error=&#39;replace&#39;，把无法编码的字符替换成?：数据损坏了，但是用户知道除了问题 xmlcharrefreplace把无法编码的字符替换成XML实体 处理UnicodeDecodeError123456789&gt;&gt;&gt; octets = b'Montr\\xe9al' &gt;&gt;&gt; octets.decode('cp1252') 'Montréa&gt;&gt;&gt; octets.decode('utf_8') # 1Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5:invalid continuation byte&gt;&gt;&gt; octets.decode('utf_8', errors='replace') # 2'Montra utf_8编解码器检测到不是有效的UTF-8字符串，抛出UnicodeDecodeError 使用replace错误处理方式，使用官方指定的替换字符，表示未知字符 使用预期之外的编码加载模块时抛出的SyntaxErrorPython 3默认使用UTF-8编码源码，Python 2则默认使用ASCII。如果加载的.py模块包换UTF-8之外的数据，而没有声明编码，会抛出SyntaxError 如何找出字节序列的编码如何找出字节序列的编码？简单来说，不能。必须有人告诉你。 可以通过试探和分析找出编码，使用编码侦测包Chardet。 12$ chardetect 04-text-byte.asciidoc04-text-byte.asciidoc: utf-8 with confidence 0.99 BOM: 有用的鬼符12345678910&gt;&gt;&gt; u16 = 'El Niño'.encode('utf_16') # 1&gt;&gt;&gt; u16b'\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x0'&gt;&gt;&gt; u16le = 'El Niño'.encode('utf_16le') # 2&gt;&gt;&gt; list(u16le)[69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0]&gt;&gt;&gt; u16be = 'El Niño'.encode('utf_16be') &gt;&gt;&gt; list(u16be)[0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 11 b&#39;\\xff\\xfe&#39;，就是BOM，即小字节序标记，指明编码时使用Intel CPU的小字节序。在小字节序设备中，各个码位的最低有效字节在前面，而大字节序设备中则相反。为了避免混肴，UTF-16编码在要编码的文本前面加上特殊的不可见字符ZERO WIDTH NO-BREAK SPACE，表明是小字节序编码。 UTF-16有两种变种：UTF-16LE，显式指明使用小字节序；UTF-16BE，显式指明使用大字节序。如果使用这两个变种，不会生产BOM。 处理文本文件处理文本的最佳实践是，Unicode三明治 。意思是，对于输入来说，要尽早把输入的字节序列解码成字符串；对于输出来说，则要尽量晚地把字符串编码成字节序列。 编码默认值：一团糟123456789101112131415161718192021import sys, localeexpressions = \"\"\" locale.getpreferredencoding() type(my_file) my_file.encoding sys.stdout.isatty() sys.stdout.encoding sys.stdin.isatty() sys.stdin.encoding sys.stderr.isatty() sys.stderr.encoding sys.getdefaultencoding() sys.getfilesystemencoding() \"\"\"my_file = open('dummy', 'w')for expression in expressions.split(): value = eval(expression) print(expression.rjust(30), '-&gt;', repr(value)) 对于不同操作系统，编码默认值可能是不一样的。 关于编码默认值的最佳建议是：别依赖默认值。如果遵从Unicode三明治的建议，而且在程序中显式指定编码，那将避免很多问题。 为了正确比较而规范化Unicode字符串12345678&gt;&gt;&gt; s1 = 'café'&gt;&gt;&gt; s2 = 'cafe\\u0301'&gt;&gt;&gt; s1, s2('café', 'café')&gt;&gt;&gt; len(s1), len(s2)(4, 5)&gt;&gt;&gt; s1 == s2False 存在这样的问题，两个字符串本质上是一样的，但python看到的是不同的码位序列，因此判定二者不相等。这就可能导致，但用户输入字符串搜索文本时，而找不到相应的文本。这个问题的解决方案是使用unicodedata.normalize函数提供的Unicode规范化。 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; from unicodedata import normalize&gt;&gt;&gt; s1 = 'café' # 把\"e\"和重音符组合在一起&gt;&gt;&gt; s2 = 'cafe\\u0301' # 分解成\"e\"和重音符&gt;&gt;&gt; len(s1), len(s2)(4, 5)&gt;&gt;&gt; len(normalize('NFC', s1)), len(normalize('NFC', s2)) # 1(4, 4)&gt;&gt;&gt; len(normalize('NFD', s1)), len(normalize('NFD', s2)) # 2(5, 5)&gt;&gt;&gt; normalize('NFC', s1) == normalize('NFC', s2)True&gt;&gt;&gt; normalize('NFD', s1) == normalize('NFD', s2)True&gt;&gt;&gt; from unicodedata import normalize, name&gt;&gt;&gt; half = '½'&gt;&gt;&gt; normalize('NFKC', half) # 3'1⁄2'&gt;&gt;&gt; four_squared = '4²'&gt;&gt;&gt; normalize('NFKC', four_squared)'42'&gt;&gt;&gt; micro = 'μ'&gt;&gt;&gt; micro_kc = normalize('NFKC', micro)&gt;&gt;&gt; micro, micro_kc('μ', 'μ')&gt;&gt;&gt; ord(micro), ord(micro_kc)(181, 956)&gt;&gt;&gt; name(micro), name(micro_kc)('MICRO SIGN', 'GREEK SMALL LETTER MU') NFC是使用最少的码位构成等价的字符串，用户输入的文本默认是用NFC形式。不过，安全起见，保存文本之前，最好使用normalize(&#39;NFC&#39;, user_text)清洗字符串 NFD是把组合字符分解成基字符和单独的组合字符 NFKC和NFKD可以把兼容字符替换成一个或多兼容分解字符，使字符更可读。使用时要小心，而且只能在特殊情况中使用，例如搜索和索引，而不能用于持久存储，因为这两种转换会导致数据损失。 大小写折叠大小写折叠就是把所有文本变成小写，再做写其他转换。这个功能由str.casefold()方法。 12345678910111213&gt;&gt;&gt; micro = 'μ'&gt;&gt;&gt; name(micro)'MICRO SIGN'&gt;&gt;&gt; micro_cf = micro.casefold()&gt;&gt;&gt; name(micro_cf)'GREEK SMALL LETTER MU'&gt;&gt;&gt; micro, micro_cf('μ', 'μ')&gt;&gt;&gt; eszett = 'ß'&gt;&gt;&gt; name(eszett)'LATIN SMALL LETTER SHARP S'&gt;&gt;&gt; eszett_cf = eszett.casefold()&gt;&gt;&gt; eszett, eszett_cf('ß', 'ss') 规范化文本匹配实用函数1234567from unicodedata import normalizedef nfc_equal(str1, str2): # 1 return normalize('NFC', str1) == normalize('NFC', str2)def fold_equal(str1, str2): # 2 return (normalize('NFC',str1).casefold()==normalize('NFC',str2).casefold()) NFC和NFD可以放心使用，而且能合理比较Unicode字符串。对于大多数应用来说，NFC是最好的规范化形式。 不区分大小写的比较应该str.casefold() 极端规范化：去掉变音符号12345678910111213141516171819202122232425262728293031323334353637383940414243444546import unicodedataimport stringdef shave_marks(txt): \"\"\"去掉全部变音符号\"\"\" norm_txt = unicodedata.normalize('NFD', txt) # 1 shaved = ''.join(c for c in norm_txt if not unicodedata.combining(c)) # 2 return unicodedata.normalize('NFC', shaved) # 3def shave_marks_latin(txt): \"\"\"把拉丁基字符中所有的变音符号删除\"\"\" norm_txt = unicodedata.normalize('NFD', txt) latin_base = False keepers = [] for c in norm_txt: if unicodedata.combining(c) and latin_base: continue # 忽略拉丁基字符上的变音符号 keepers.append(c) if not unicodedata.combining(c): # 如果不是组合字符，那就是新的基字符 latin_base = c in string.ascii_letters shaved = ''.join(keepers) return unicodedata.normalize('NFC', shaved） single_map = str.maketrans(\"\"\"‚ƒ„†ˆ‹‘’“”•–—˜›\"\"\", # 4 \"\"\"'f\"*^&lt;''\"\"---~&gt;\"\"\")multi_map = str.maketrans(&#123; '€': '&lt;euro&gt;', '…': '...', 'Œ': 'OE', '™': '(TM)', 'œ': 'oe', '‰': '&lt;per mille&gt;', '‡': '**',&#125;)multi_map.update(single_map) def dewinize(txt): \"\"\"Replace Win1252 symbols with ASCII chars or sequences\"\"\" return txt.translate(multi_map) def asciize(txt): no_marks = shave_marks_latin(dewinize(txt)) no_marks = no_marks.replace('ß', 'ss') return unicodedata.normalize('NFKC', no_marks) 把所有字符分解成基字符和组合记号 过滤掉所有组合记号 重组 更彻底的规范化步骤是把西文文本中常见符号替换成ASCII的对等字符，构建字符替换映射表 Unicode文本排序不同的区域采用的排序规则有所不同，葡萄牙语等很多语言按照拉丁字母表排序，英语汉语则按照英文字母表排序。在Python中，非ASCII文本的标准排序方式是使用locale.strxfrm，前提是操作支持区域设置。 123456&gt;&gt;&gt; import pyuca&gt;&gt;&gt; coll = pyuca.Collator()&gt;&gt;&gt; fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola']&gt;&gt;&gt; sorted_fruits = sorted(fruits, key=coll.sort_key)&gt;&gt;&gt; sorted_fruits['açaí', 'acerola', 'atemoia', 'cajá', 'caju'] PyUCA没有考虑区域设置。如果想定制排序方式，可以把自定义的排序表路径传给Collator()构造方法。PyUCA默认使用项目自带的allkeys.txt Unicode数据库Unicode数据库记录了字符是否可以打印、是不是字母、是不是数字，或者是不是其他数值符号。字符串的isidentitier、isprintable、isdecimal、isnumeric等方法就是靠这些信息作判断的。 12345678910111213141516import unicodedataimport rere_digit = re.compile(r'\\d')sample = '1\\xbc\\xb2\\u0969\\u136b\\u216b\\u2466\\u2480\\u3285'for char in sample: print('U+%04x' % ord(char), # &lt;1&gt; char.center(6), # &lt;2&gt; 're_dig' if re_digit.match(char) else '-', # &lt;3&gt; 'isdig' if char.isdigit() else '-', # &lt;4&gt; 'isnum' if char.isnumeric() else '-', # &lt;5&gt; format(unicodedata.numeric(char), '5.2f'), # &lt;6&gt; unicodedata.name(char), # &lt;7&gt; sep='\\t') 支持字符串和字节序列的双模式API正则表达式中的字符串和字节序列12345678910111213141516171819import rere_numbers_str = re.compile(r'\\d+') # &lt;1&gt;re_words_str = re.compile(r'\\w+')re_numbers_bytes = re.compile(rb'\\d+') # &lt;2&gt;re_words_bytes = re.compile(rb'\\w+')text_str = (\"Ramanujan saw \\u0be7\\u0bed\\u0be8\\u0bef\" # &lt;3&gt; \" as 1729 = 1³ + 12³ = 9³ + 10³.\") # &lt;4&gt;text_bytes = text_str.encode('utf_8') # &lt;5&gt;print('Text', repr(text_str), sep='\\n ')print('Numbers')print(' str :', re_numbers_str.findall(text_str)) # &lt;6&gt;print(' bytes:', re_numbers_bytes.findall(text_bytes)) # &lt;7&gt;print('Words')print(' str :', re_words_str.findall(text_str)) # &lt;8&gt;print(' bytes:', re_words_bytes.findall(text_bytes)) # &lt;9&gt; os函数中的字符串和字节序列12345678910&gt;&gt;&gt; os.listdir('.') ['abc.txt', 'digits-of-π.txt']&gt;&gt;&gt; os.listdir(b'.') [b'abc.txt', b'digits-of-\\xcf\\x80.txt']&gt;&gt;&gt; pi_name_bytes = os.listdir(b'.')[1] &gt;&gt;&gt; pi_name_str = pi_name_bytes.decode('ascii', 'surrogateescape') # 1&gt;&gt;&gt; pi_name_str 'digits-of-\\udccf\\udc80.txt'&gt;&gt;&gt; pi_name_str.encode('ascii', 'surrogateescape') # 2b'digits-of-\\xcf\\x80.t 使用ascii编解码器和surrogateescape错误处理方式把它解码成字符串，Windows使用的错误处理方式是strict 编码成ASCII字节序列，各个代替码位还原成被替换的字节","tags":[{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"}]},{"title":"Django 工程结构","date":"2018-05-30T06:54:59.640Z","path":"2018/05/30/Python-Django-Architecture/","text":"安装必要包1pip install django djangorestframework markdown django-filter 创建项目1234567891011mkdir MxShopcd MxShopdjango-admin startproject MxShoptree├── manage.py # 使用命令行与Django项目进行交互└── MxShop # 项目容器 ├── __init__.py # 空文件，表明这是一个python包 ├── settings.py # Django项目的设置/配置 ├── urls.py # url声明 └── wsgi.py # Web服务器入口 创建app1python manage.py startapp users 数据库配置12345678910111213141516# 修改django数据库配置，针对mysql5.6vim settings.pyDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': \"mxshop\", 'USER': 'root', 'PASSWORD': \"abc19900514\", 'HOST': \"192.168.3.56\", 'OPTIONS': &#123; 'init_command': 'SET default_storage_engine=INNODB;' &#125; &#125;&#125;# 在mysql中创建数据库mysql -u root -pCREATE DATABASE mxshop DEFAULT CHARACTER SET utf8; 项目结构123456789101112131415161718192021222324252627282930313233cd /home/MxShop/mkdir apps mv usrs app/touch apps/__init__.py mkdir extra_apps touch extra_apps/__init__.py mkdir templates mkdir db_tools mkdir media tree├── apps # 存放所有app│ ├── __init__.py│ └── users│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ └── views.py├── db_tools # 存放python脚本├── extra_apps # 存放第三方包，修改源码│ └── __init__.py├── manage.py├── media # 存放图片├── MxShop│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py└── templates # 存放静态文件 包的路径设置1234567# vim settings.pyimport sys# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, BASE_DIR)sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))sys.path.insert(0, os.path.join(BASE_DIR, 'extra_apps')) 新增app12345678python manage.py startapp goods # 商品mv goods appspython manage.py startapp trade # 交易mv trade appspython manage.py startapp user_operation # 用户caomv user_operation apps 设计Model12345678910111213141516171819vim settings.pyAUTH_USER_MODEL = \"users.UserProfile\"# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'users.apps.UsersConfig', 'DjangoUeditor', 'goods.apps.GoodsConfig', 'trade.apps.TradeConfig', 'user_operation.apps.UserOperationConfig',] 数据表生成123456# 凡是修改model，必须运行这两条命令# 生成代码python .\\manage.py makemigrations# 生成数据表python .\\manage.py migrate 后台管理系统xadmin1234567891011121314151617181920212223242526272829303132333435363738394041424344# 安装xadmin及其依赖# xadmin使用crispy-forms插件来美化文档，安装并加入到配置pip install django-crispy-formsINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'users.apps.UsersConfig', 'DjangoUeditor', 'goods.apps.GoodsConfig', 'trade.apps.TradeConfig', 'user_operation.apps.UserOperationConfig', 'crispy_forms', 'xadmin']# 为每个app配置adminx.py# 生成数据表# 修改admin为xadminimport xadminurlpatterns = [ url(r'^xadmin/', xadmin.site.urls),]# 创建超级用户python .\\manage.py createsuperuser# 设置中文及时区#设置时区LANGUAGE_CODE = 'zh-hans' #中文支持，django1.8以后支持；1.8以前是zh-cnTIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False #默认是Ture，时间是utc时间，由于我们要用本地时间，所用手动修改为false！！！！# 登录后台管理系统http://localhost:8000/xadmin 导入数据123456789101112131415# 入库脚本import sysimport os# 加入环境搜索路径pwd = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))sys.path.append(pwd) os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"MxShop.settings\") # 设置环境变量，可以单独使用django的Modelimport djangodjango.setup()from goods.models import GoodsCategoryfrom db_tools.data.category_data import row_data 配置文件访问路径12345678910111213141516vim settings.pyMEDIA_URL = \"/media/\"MEDIA_ROOT = os.path.join(BASE_DIR, \"media\")vim urls.pyfrom django.conf.urls import url# from django.contrib import adminimport xadminfrom MxShop.settings import MEDIA_ROOTfrom django.views.static import serveurlpatterns = [ url(r'^xadmin/', xadmin.site.urls), url(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;\"document_root\": MEDIA_ROOT&#125;),] 序列化方法1234567# 使用django自带的序列化方法，使用JsonResponse代替HttpResponse返回jsonimport jsonfrom django.core import serializersfrom django.http import JsonResponsejson_data = serializers.serialize(\"json\", goods)json_data = json.loads(json_data) # 转换成字典return JsonResponse(json_data, safe=False) 配置Django REST framework12345678910111213141516171819202122232425262728293031323334# 安装Django REST framework依赖包pip install djangorestframeworkpip install markdown # Markdown support for the browsable API.pip install django-filter # Filtering supportpip install coreapi # 生成文档# 配置url, vim urls.pyfrom rest_framework.documentation import include_docs_urlsurlpatterns = [ url(r'docs/', include_docs_urls(title=\"Mall\")), # api文档]# 配置app, vim settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'users.apps.UsersConfig', 'DjangoUeditor', 'goods.apps.GoodsConfig', 'trade.apps.TradeConfig', 'user_operation.apps.UserOperationConfig', 'crispy_forms', 'xadmin', 'rest_framework',]# 配置drf的urlurlpatterns = [ url(r'^api-auth/', include('rest_framework.urls'))] 使用drf序列化方法1234567891011121314# 新建serializers.py# 根据字段映射from rest_framework import serializersclass GoodsSerializer(serializers.Serializer): name = serializers.CharField(required=True, max_length=100) click_num = serializers.IntegerField(default=0) goods_front_image = serializers.ImageField() # 根据model映射class GoodsSerializer(serializers.ModelSerializer): category = CategorySerializer() # 加入外键信息 class Meta: model = Goods fields = \"__all__\" # 序列化所有字段 使用drf精简视图层代码1234567891011121314151617181920212223242526# 原代码class GoodsListView(APIView): \"\"\" List all snippets, or create a new snippet. \"\"\" def get(self, request, format=None): goods = Goods.objects.all()[:10] # 使用dsf提供的序列化方法 goods_serializer = GoodsSerializer(goods, many=True) return Response(goods_serializer.data)# 精简代码class GoodsListView(mixins.ListModelMixin, generics.GenericAPIView): queryset = Goods.objects.all()[:10] serializer_class = GoodsSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) # 再次精简代码class GoodsListView(generics.ListAPIView): queryset = Goods.objects.all()[:10] serializer_class = GoodsSerializer 使用drf分页12345# vim settings.pyREST_FRAMEWORK = &#123; 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination', 'PAGE_SIZE': 10&#125; 使用drf分页，搜索，过滤，排序1234567891011121314151617181920# vim settings.pyINSTALLED_APPS = [ 'django_filters']# vim views.pyfrom django_filters.rest_framework import DjangoFilterBackendclass GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): \"\"\" 商品列表页，分页，搜索，过滤，排序 \"\"\" queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter) # 配置过滤，搜索，排序 # filter_fields = ('name', 'shop_price') filter_class = GoodsFilter search_fields = ('=name', 'goods_desc', 'goods_brief') # 模糊查询 ordering_fields = ('sold_num', 'add_time') 跨域设置123456789101112131415161718pip install django-cors-headers# vim settings.pyINSTALLED_APPS = ( 'corsheaders',)MIDDLEWARE = [ 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware',]CORS_ORIGIN_WHITELIST = ( 'google.com', 'hostname.example.com', 'localhost:8000', '127.0.0.1:9000') 自定义过滤12345678910111213class GoodsFilter(django_filters.rest_framework.FilterSet): pricemin = django_filters.NumberFilter(name='shop_price', lookup_expr='gte') pricemax = django_filters.NumberFilter(name='shop_price', lookup_expr='lte') # name = django_filters.CharFilter(name='name', lookup_expr='icontains') # 模糊查询 top_category = django_filters.NumberFilter(method=\"top_category_filter\") def top_category_filter(self, queryset, name, value): return queryset.filter(Q(category_id=value)|Q(category__parent_category_id=value)|Q(category__parent_category__parent_category_id=value)) class Meta: model = Goods fields = ['pricemin', 'pricemax', 'name'] 用户验证1234567891011121314151617# vim settings.pyREST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.BasicAuthentication', 'rest_framework.authentication.SessionAuthentication', )&#125;INSTALLED_APPS = ( 'rest_framework.authtoken')# vim urls.pyfrom rest_framework.authtoken import viewsurlpatterns += [ url(r'^api-token-auth/', views.obtain_auth_token)] 自定义验证12345678910111213141516171819202122232425262728# vim settings.pyAUTHENTICATION_BACKENDS = ( 'users.views.CustomBackend',)JWT_AUTH = &#123; 'JWT_EXPIRATION_DELTA': datetime.timedelta(days=7), 'JWT_AUTH_HEADER_PREFIX': 'JWT',&#125;# vim users/views.pyfrom django.contrib.auth.backends import ModelBackendfrom django.contrib.auth import get_user_modelfrom django.db.models import QUser = get_user_model()class CustomBackend(ModelBackend): \"\"\" 自定义用户验证 \"\"\" def authenticate(self, request, username=None, password=None, **kwargs): try: user = User.objects.get(Q(username=username)|Q(mobile=username)) if user.check_password(password): return user except Exception as e: return None","tags":[{"name":"Web","slug":"Web","permalink":"http://printxhl.com/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://printxhl.com/tags/Django/"}]},{"title":"Fluent Python (3)：面向对象","date":"2018-05-30T06:54:59.526Z","path":"2018/05/30/Python-FlunetPython-class/","text":"对象引用、可变性和垃圾回收变量不是盒子一言以蔽之，变量名是存在于内存中真实对象的一个标签而已，一个对象可以贴多个标签。 标识、相等性和别名在==和is之间选择 ==运算符比较两个对象中保存的值，而is比较对象的id 通常关注对象值而不是标识，所以==出现频率比is高。最常使用is检测变量绑定值是不是None，x is None is运算符比==速度快，因为它不重载，所以不用寻找并调用特殊方法。而==是语法糖，等同于a.__eq__(b) 元组的相对不可变性12345678910111213&gt;&gt;&gt; t1 = (1, 2, [30, 40]) &gt;&gt;&gt; t2 = (1, 2, [30, 40]) &gt;&gt;&gt; t1 == t2 True&gt;&gt;&gt; id(t1[-1]) 4302515784&gt;&gt;&gt; t1[-1].append(99) &gt;&gt;&gt; t1(1, 2, [30, 40, 99])&gt;&gt;&gt; id(t1[-1]) 4302515784&gt;&gt;&gt; t1 == t2 False 元组的值会随着引用对象的变化而变，元组中不可变的是元素的标识。 默认做浅复制12345678&gt;&gt;&gt; l1 = [3, [55, 44], (7, 8, 9)]&gt;&gt;&gt; l2 = list(l1) # 1 &gt;&gt;&gt; l2[3, [55, 44], (7, 8, 9)]&gt;&gt;&gt; l2 == l1 True&gt;&gt;&gt; l2 is l1 # 2False l2 = list(l1)等价于l2 = l1[:]等价于l2 = l1.copy() list(l1)创建l1的副本，二者值相等，但是指代不同的对象 123456789101112131415161718192021222324252627class Bus: def __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers) def pick(self, name): self.passengers.append(name) def drop(self, name): self.passengers.remove(name) &gt;&gt;&gt; import copy&gt;&gt;&gt; bus1 = Bus(['Alice', 'Bill', 'Claire', 'David'])&gt;&gt;&gt; bus2 = copy.copy(bus1)&gt;&gt;&gt; bus3 = copy.deepcopy(bus1)&gt;&gt;&gt; id(bus1), id(bus2), id(bus3)(4301498296, 4301499416, 4301499752) &gt;&gt;&gt; bus1.drop('Bill')&gt;&gt;&gt; bus2.passengers['Alice', 'Claire', 'David'] &gt;&gt;&gt; id(bus1.passengers), id(bus2.passengers), id(bus3.passengers) # 1(4302658568, 4302658568, 4302657800) &gt;&gt;&gt; bus3.passengers['Alice', 'Bill', 'Claire', 'David'] # 2 bus1和bus2共享一个列表对象，因为bus2是bus1的浅复制副本 bus3是bus1的深复制副本，因为它的passengers属性指代另一个列表 函数的参数作为引用时不要使用可变类型作为参数的默认值12345678class HauntedBus:def __init__(self, passengers=[]): self.passengers = passengers def pick(self, name): self.passengers.append(name) def drop(self, name): self.passengers.remove(name) 本例中使用列表作为默认值，当不同实例按默认值初始化时，将导致不同实例的passengers指代同一个列表 防御可变参数1234567891011class TwilightBus: def __init__(self, passengers=None): if passengers is None: self.passengers = [] # 1 else: self.passengers = list(passengers) # 2 def pick(self, name): self.passengers.append(name) def drop(self, name): self.passengers.remove(name) 当passengers为None时，创建一个新的空列表，防御可变参数 不要影响初始化校车时传入的参数，如果不是列表就转换成列表 del和垃圾回收 del语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用 如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而把它们都销毁 在CPython中，垃圾回收使用的主要算法是引用计数。每个对象都会统计有多少引用指向自己，当引用计数归零时，对象立即被销毁：CPython会在对象上调用__del__方法，然后释放分配给对象的内存 弱引用1234567891011121314&gt;&gt;&gt; import weakref &gt;&gt;&gt; a_set = &#123;0, 1&#125;&gt;&gt;&gt; wref = weakref.ref(a_set) # 1&gt;&gt;&gt; wref&lt;weakref at 0x100637598; to 'set' at 0x100636748&gt;&gt;&gt;&gt; wref() # 2&#123;0, 1&#125;&gt;&gt;&gt; a_set = &#123;2, 3, 4&#125; &gt;&gt;&gt; wref() # 3&#123;0, 1&#125;&gt;&gt;&gt; wref() is None # 4False&gt;&gt;&gt; wref() is None True 创建弱引用对象wref，弱应用不会增加对象的引用数量，若引用并不会妨碍所指对象被当作垃圾回收 调用wref()返回的是被引用对象，{0, 1}。因为这是控制台会话，所以{0, 1}会绑定给_变量 a_set不再指代{0, 1}集合，因此集合的引用数量减少了，但是_变量仍然指代它 计算这个表达式时，{0, 1}存在，因此wref()不是None。但是随后_绑定到结果值False。现在{0, 1}没有强引用了 WeakValueDictionary简介123456789101112131415161718192021222324class Cheese: def __init__(self, kind): self.kind = kind def __repr__(self): return 'Cheese(%r)' % self.kind &gt;&gt;&gt; import weakref&gt;&gt;&gt; stock = weakref.WeakValueDictionary() &gt;&gt;&gt; catalog = [Cheese('Red Leicester'), Cheese('Tilsit'),... Cheese('Brie'), Cheese('Parmesan')]&gt;&gt;&gt; for cheese in catalog:... stock[cheese.kind] = cheese &gt;&gt;&gt; sorted(stock.keys())['Brie', 'Parmesan', 'Red Leicester', 'Tilsit'] &gt;&gt;&gt; del catalog&gt;&gt;&gt; sorted(stock.keys())['Parmesan'] &gt;&gt;&gt; del cheese&gt;&gt;&gt; sorted(stock.keys())[] 弱引用的局限123456class MyList(list): \"\"\"list的子类，实例可以作为弱引用的目标\"\"\" a_list = MyList(range(10))# a_list可以作为弱引用的目标wref_to_a_list = weakref.ref(a_list) 不是每个Python对象都可以作为弱引用的目标，基本的list和dict实例不能作为所指的对象，但是它们的子类可以解决这个问题。 符合Python风格的对象对象表现形式 repr()：以便于开发者理解的方式返回对象的字符串表示形式 str()：以便于用户理解的方式返回对象的字符串表示形式 向量类1234567891011121314151617181920212223242526272829303132from array import arrayimport mathclass Vector2d: typecode = 'd' # 1 def __init__(self, x, y): self.x = float(x) self.y = float(y) def __iter__(self): return (i for i in (self.x, self.y)) def __repr__(self): class_name = type(self).__name__ return '&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'.format(class_name, *self) # 2 def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self))) # 3 def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.hypot(self.x, self.y) def __bool__(self): return bool(abs(self)) typecode是类属性，在Vector2d实例和字节序列之间转换时使用 | Type code | C Type | Python Type | Minimum size in bytes | Notes || ——— | —————— | —————– | ——————— | —– || &#39;b&#39; | signed char | int | 1 | || &#39;B&#39; | unsigned char | int | 1 | || &#39;u&#39; | Py_UNICODE | Unicode character | 2 | (1) || &#39;h&#39; | signed short | int | 2 | || &#39;H&#39; | unsigned short | int | 2 | || &#39;i&#39; | signed int | int | 2 | || &#39;I&#39; | unsigned int | int | 2 | || &#39;l&#39; | signed long | int | 4 | || &#39;L&#39; | unsigned long | int | 4 | || &#39;q&#39; | signed long long | int | 8 | (2) || &#39;Q&#39; | unsigned long long | int | 8 | (2) || &#39;f&#39; | float | float | 4 | || &#39;d&#39; | double | float | 8 | | __repr__方法使用{!r}获取各个分量的表示形式，然后插值，构成一个字符串。因为Vector2d实例是可迭代对象，所以*self会把x和y分量提供给format函数 迭代Vector2d实例，得到一个数组，再把数组转换成字节序列。ord()是chr()的配对函数，以一个字符作为参数，返回对应的ASCII数值 备选构造方法12345@classmethod # 1def frombytes(cls, octets): typecode = chr(octets[0]) # 2 memv = memoryview(octets[1:]).cast(typecode) # 3 return cls(*memv) # 4 使用classmethod装饰器定义备选构造方法，可以使用Vector2d.frombytes(octets)把字节序列转换成Vector2d实例。 从第一个字节中读取typecode 使用传入的octets字节序列创建一个memoryview，然后使用typecode转换 拆包转换后的memoryview，得到构造方法所需的一对参数 classmethod与staticmethod123456789101112131415161718class Demo: @classmethod def klassmeth(*args): return args @staticmethod def statmeth(*args): return args&gt;&gt;&gt; Demo.klassmeth() (&lt;class '__main__.Demo'&gt;,)&gt;&gt;&gt; Demo.klassmeth('spam')(&lt;class '__main__.Demo'&gt;, 'spam')&gt;&gt;&gt; Demo.statmeth() ()&gt;&gt;&gt; Demo.statmeth('spam')('spam',) classmethod，定义操作类而不是操作实例的方法，最常见的用途是定义备选构造方法 staticmethod，静态方法其实就是普通的函数，只是碰巧在类的定义中，而不是在模块层定义。有时函数虽然从不处理类，但是函数的功能和类密切相关，想把它放在近处让代码好看点，并不是特别有用 格式化显示 str.format() 1234567891011121314151617 def __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): # 1 fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '&lt;&#123;&#125;, &#123;&#125;&gt;' # 2 else: coords = self outer_fmt = '(&#123;&#125;, &#123;&#125;)' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components) &gt;&gt;&gt; format(Vector2d(1, 1), 'p')'&lt;1.4142135623730951, 0.7853981633974483&gt;'&gt;&gt;&gt; format(Vector2d(1, 1), '.3ep')'&lt;1.414e+00, 7.854e-01&gt;'&gt;&gt;&gt; format(Vector2d(1, 1), '0.5fp')'&lt;1.41421, 0.78540&gt;' 如果格式代码以p结尾，使用极坐标。如果不是，则使用直角坐标 定义格式化的模板，极坐标用尖括号，直角坐标用圆括号 可散列的Vector2d123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from array import arrayimport mathclass Vector2d: typecode = 'd' def __init__(self, x, y): self.__x = float(x) # 1 self.__y = float(y) @property # 2 def x(self): return self.__x @property def y(self): return self.__y def __iter__(self): return (i for i in (self.x, self.y)) def __repr__(self): class_name = type(self).__name__ return '&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'.format(class_name, *self) def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self))) def __eq__(self, other): return tuple(self) == tuple(other) def __hash__(self): return hash(self.x) ^ hash(self.y) # 3 def __abs__(self): return math.hypot(self.x, self.y) def __bool__(self): return bool(abs(self)) def angle(self): return math.atan2(self.y, self.x) def __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '&lt;&#123;&#125;, &#123;&#125;&gt;' else: coords = self outer_fmt = '(&#123;&#125;, &#123;&#125;)' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv) 使用两个前导下划线，把属性标记为私有的 @property装饰器把读值方法标记为特性 要创建可散列的类型，只需正确地实现__hash__和__eq__方法，但是实例的散列值绝不应该变化，因此使用了只读属性。最好使用位运算异或^混合各分量的散列值。 Python的私有属性和受保护属性12345&gt;&gt;&gt; v1 = Vector2d(3, 4)&gt;&gt;&gt; v1.__dict__&#123;'_Vector2d__y': 4.0, '_Vector2d__x': 3.0&#125;&gt;&gt;&gt; v1._Vector2d__x3.0 self.__x被称为私有属性，这个私有属性硬要通过实例来访问的话，可以使用v1._Vector2d__x self._x被称为受保护属性，名称不会被解释器改写 使用__slots__类属性节省空间1234class Vector2d: __slots__ = ('__x', '__y') typecode = 'd' 在类中定义__slots__属性的目的是告诉解释器，这个类的所有属性都在这了。这样Python会在各个实例中使用类似元组的结构存储实例变量，从避免使用消耗内存的__dict__属性。如果有数百万个实例同时活动，这样做能节省大量的内存 每个子类都要定义__slots__属性，因为解释器会忽略继承的__slots__属性 实例只能拥有__slots__中列出的属性，除非把__dict__加入__slots__中，这样做就失去了节省内存的功效 如果不把__weakref__加入__slots__，实例就不能作为弱引用的目标 覆盖类属性1234567891011121314&gt;&gt;&gt; v1 = Vector2d(1.1, 2.2)&gt;&gt;&gt; dumpd = bytes(v1)&gt;&gt;&gt; dumpdb'd\\x9a\\x99\\x99\\x99\\x99\\x99\\xf1?\\x9a\\x99\\x99\\x99\\x99\\x99\\x01@'&gt;&gt;&gt; len(dumpd) 17&gt;&gt;&gt; v1.typecode = 'f' # 2&gt;&gt;&gt; dumpf = bytes(v1)&gt;&gt;&gt; dumpfb'f\\xcd\\xcc\\x8c?\\xcd\\xcc\\x0c@'&gt;&gt;&gt; len(dumpf) 9&gt;&gt;&gt; Vector2d.typecode # 2'd' 把v1实例的typecode属性设为f Vector2d.typecode属性的值不变，只有v1实例的typecode属性使用f 123456789&gt;&gt;&gt; from vector2d_v3 import Vector2d&gt;&gt;&gt; class ShortVector2d(Vector2d): # 1... typecode = 'f'...&gt;&gt;&gt; sv = ShortVector2d(1/11, 1/27) &gt;&gt;&gt; svShortVector2d(0.09090909090909091, 0.037037037037037035) &gt;&gt;&gt; len(bytes(sv)) 9 创建一个子类，只用于覆盖typecode类属性 序列的修改、散列和切片Vector类：用户定义的序列类型Vector类第1版：与Vector2d类兼容序列类型的构造方法最好接受可迭代的对象参数，因为所有内置的序列类型都是这样做的。 12345678910111213141516171819202122232425262728293031323334353637383940from array import arrayimport reprlibimport mathclass Vector: typecode = 'd' def __init__(self, components): self._components = array(self.typecode, components) # &lt;1&gt; def __iter__(self): return iter(self._components) # &lt;2&gt; def __repr__(self): components = reprlib.repr(self._components) # &lt;3&gt; components = components[components.find('['):-1] # &lt;4&gt; return 'Vector(&#123;&#125;)'.format(components) def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components)) def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.sqrt(sum(x * x for x in self)) def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv) # &lt;5&gt; self._components是受保护的实例属性，把Vector的分量保存在一个数组中 为了迭代，使用self._components构建一个迭代器 使用reprlib.repr()函数获取self._compoents的有限长度表示形式，如array(&#39;d&#39;,[0,1,2,3,4,...] 把字符串插入Vector的构造方法调用之前，去掉前面的array(&#39;d和后面的)。 直接把memoryview传给构造方法，不用像前面那样使用*拆包 Vector类第2版：可切片的序列在面向对象编程中，协议是非正式的接口，只在文档中定义不在代码中定义。例如，Python的序列协议只需要实现__len__和__getitem__两个方法。任何类只要实现了这两个方法，就可切片。协议是非正式的，没有强制力，为了支持迭代，只需实现__getitem__方法，没必要提供__len__方法。所以鸭子类型的意思是，只要这个类实现了__getitem__方法，那么我们就说它是序列，因为它的行为像序列，这才是重点。 123456789101112def __len__(self): return len(self._components)def __getitem__(self, index): cls = type(self) # 1 if isinstance(index, slice): # 2 return cls(self._components[index]) elif isinstance(index, numbers.Integral): # 3 return self._components[index] else: msg = '&#123;cls.__name__&#125; indices must be integers' raise TypeError(msg.format(cls=cls)) 获取实例所属的类，供后面使用 如果index参数的值是slice对象，调用类的构造方法，使用_components数组的切片构建一个新的Vector实例。 如果index是int或其他整数类型，那就返回_components中相应的元素 Vector类第3版：动态存取属性使用单个字母访问前几个分量。 在Vector2d中，使用 @property装饰器可以把x和y标记为只读特性。在Vector中也可以这样做，但是太麻烦，使用__getattr__更方便。属性查找失败后，解释器会调用__getattr__方法。简单来说，对my_obj.x表达式，解释器会先检查实例有没有x属性，如果没有再检查类my_obj.__class__中查找，如果没有再顺着继承树查找，实在找不到就调用my_obj所属类中定义的__getattr__方法。 123456789101112131415161718192021222324shortcut_names = 'xyzt'def __getattr__(self, name): cls = type(self) if len(name) == 1: pos = cls.shortcut_names.find(name) # 1 if 0 &lt;= pos &lt; len(self._components): return self._components[pos] msg = '&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;' raise AttributeError(msg.format(cls, name))def __setattr__(self, name, value): cls = type(self) if len(name) == 1: if name in cls.shortcut_names: # 2 error = 'readonly attribute &#123;attr_name!r&#125;' elif name.islower(): error = \"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;\" else: error = '' if error: msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value) # 3 查找那个字母的位置，如果位置落在范围内，返回数组对应的元素 如果name是xyzt中的一个，设置特殊的错误信息，避免用户私自设置类的属性 在超类上调用__setattr__方法。super()函数用于动态访问超类的方法，使用这个函数把子类的方法的某些任务委托给超类中适当的方法。 Vector第4版：散列和快速等值测试通过实现__hash__方法，加上现有的__eq__方法，把Vector实例变成可以散列的对象。 12345678def __hash__(self): # hashes = (hash(x) for x in self) hashes = map(hash, self._components) # 1 return functools.reduce(operator.xor, hashes, 0) # 2def __eq__(self, other): return (len(self) == len(other) and all(a == b for a, b in zip(self, other))) Python 2中使用map函数效率低些，因为map函数要使用结果构建一个列表，但在Python 3中，map函数是惰性的，它会创建一个生成器，按需产出结果，因此节省内存 把hashes提供给reduce函数，使用xor函数计算聚合的散列值，第三个参数，0是初始值。对于+、|和^来说，初始值应该是0。对于*和&amp;来说，初始值应该是1。 zip函数生成一个由元组构成的生成器，元组中的元素来自各个可迭代对象。前面比较长度测试时有必要的，因为一旦有一个输入耗尽，zip函数会立即停止生成值，而且不发出警告，你就发现不了问题了。只要有一次比较的结果是False，all函数就返回False。 Vector第5版：格式化因为Vector类支持n个维度，而超过四维后，球体变成超球体。所以Vector类的__format__方法就要使用球面坐标。 123456789101112131415161718192021def angle(self, n): # 1 r = math.sqrt(sum(x * x for x in self[n:])) a = math.atan2(r, self[n-1]) if (n == len(self) - 1) and (self[-1] &lt; 0): return math.pi * 2 - a else: return adef angles(self): return (self.angle(n) for n in range(1, len(self))) # 2def __format__(self, fmt_spec=''): if fmt_spec.endswith('h'): # hyperspherical coordinates fmt_spec = fmt_spec[:-1] coords = itertools.chain([abs(self)], self.angles()) # 3 outer_fmt = '&lt;&#123;&#125;&gt;' else: coords = self outer_fmt = '(&#123;&#125;)' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(', '.join(components)) 使用公式计算某个角座标 创建生成器表达式，按需计算所有角座标 使用itertools.chain函数生成器表达式，无缝接待向量的模和各个角座标 接口：从协议到抽象基类Python文化中的接口和协议 接口：抽象类就是接口，实现特定角色的方法集合，如文件类对象或可迭代对象，一个类可能会实现多个接口，从而让实例扮演多个角色 协议：协议是接口，但不是正式的，只由文档和约定定义，因此协议不能像正式接口那样施加限制，一个类可能只实现了部分接口，这是允许的 Python喜欢序列Python数据模型的哲学是尽量支持基本协议。 123class Foo: def __getitem__(self, pos): return range(0, 30, 10)[pos] Foo类没有继承abs.Sequence，而且只实现了序列协议的一个方法__getitem__，这样足够访问元素、迭代和使用in运算符了。鉴于序列协议的重要性，如果没有__iter__和__contains__方法，Python会调用__getitem__方法，设法让迭代和in运算符可用。 使用猴子补丁在运行时实现协议如果遵守既定协议，很可能增加利用现有的标准库和第三方代码的可能性，这得益于鸭子类型。 1234567&gt;&gt;&gt; from random import shuffle&gt;&gt;&gt; def set_card(deck, position, card): # 1... deck._cards[position] = card...&gt;&gt;&gt; FrenchDeck.__setitem__ = set_card # 2&gt;&gt;&gt; shuffle(deck) # 3&gt;&gt;&gt; deck[:5][Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4',suit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')] 每个Python方法说白了就是普通函数，把第一个参数命名为self只是一种约定，按照文档那样应该使用set_card(self, key, value。 Python是动态语言，可以在运行时提供__setitem__方法，实现可变序列协议。这种在运行时修改类或模块而不改变源码的技术叫做猴子补丁，但是打补丁的代码必须与要打补丁的程序耦合紧密，而且要处理隐藏和没有文档的部分。 random.shuffle函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。这就是所谓的鸭子类型：对象的类型无关紧要，只要实现了特定的协议即可。 鸭子类型 vs 白鹅类型 鸭子类型：忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义，这基本上避免了使用isinstance检查对象类型。 白鹅类型：只要cls是抽象基类，即cls的元类是abc.ABCMeta，就可以使用isinstance(obj, cls) 定义抽象基类的子类1234567891011121314151617181920212223242526import collectionsCard = collections.namedtuple('Card', ['rank', 'suit'])class FrenchDeck2(collections.MutableSequence): ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] def __setitem__(self, position, value): # &lt;1&gt; self._cards[position] = value def __delitem__(self, position): # &lt;2&gt; del self._cards[position] def insert(self, position, value): # &lt;3&gt; self._cards.insert(position, value) 为了支持洗牌，只需实现__setitem__方法 但是继承MutableSequence的类必须实现__delitem__方法 此外还必须实现insert方法，如果没有实现那么实例化时会报错 标准库中的抽象基类collections.abc模块中的抽象基类 Iterable、Container和Sized 各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。Iterable通过__iter__方法支持迭代，Container通过__contains__方法支持in运算符，Sized通过__len__方法支持len()函数 Sequence、Mapping和Set 这三个是主要的不可变集合类型，而各自都有可变的子类。 MappingView 映射.items()、.keys()和.values()返回的对象分别是ItemsView、KeyView和ValuesView的实例。前两个类还从Set类继承了丰富的接口 Callable和Hashable 这两个抽象基类与集合没有太大的关系。这两个抽象基类的主要作用是为内置函数isinstance提供支持，以一种安全的方式判断对象能不能调用或散列 Iterator 注意它是Iterable的子类 抽象基类的数字塔numbers包定义的是数字塔，其中Number是位于最顶端的超类，随后是Complex子类，依次往下，最低端是Integral类： Number Complex Real Rational Integral 定义并使用一个抽象基类定义一个支持用户提供随机挑选的无重复类。 123456789101112131415161718192021222324252627282930import abcclass Tombola(abc.ABC): # &lt;1&gt; @abc.abstractmethod def load(self, iterable): # &lt;2&gt; \"\"\"Add items from an iterable.\"\"\" @abc.abstractmethod def pick(self): # &lt;3&gt; \"\"\"Remove item at random, returning it. This method should raise `LookupError` when the instance is empty. \"\"\" def loaded(self): # &lt;4&gt; \"\"\"Return `True` if there's at least 1 item, `False` otherwise.\"\"\" return bool(self.inspect()) def inspect(self): \"\"\"Return a sorted tuple with the items currently inside.\"\"\" items = [] while True: try: items.append(self.pick()) except LookupError: break self.load(items) return tuple(sorted(items)) 自己定义的抽象基类要继承abc.ABC 抽象方法使用@abstractmethod装饰器标记，而且定义体中通常只有文档字符串 根据文档字符串，如果没有元素可选时，应该抛出LookupError 抽象基类中可以包含具体方法，只能使用抽象基类中的其他具体方法、抽象方法或特性 抽象基类句法详解 声明抽象基类最简单的方式是继承abc.ABC，旧版中是这样的class Tombola(metaclass=abc.ABCMeta):，更旧版中在类中声明__metaclass__ = abc.ABCMeta 在@abstractmethod和def语句之间不能有其他装饰器，也就是说其他装饰器要堆叠在@abstractmethod的上面 定义Tombola抽象基类的子类开发两个子类，满足Tombola规定的接口。 12345678910111213141516171819202122import randomfrom tombola import Tombolaclass BingoCage(Tombola): # &lt;1&gt; def __init__(self, items): self._randomizer = random.SystemRandom() # &lt;2&gt; self._items = [] self.load(items) def load(self, items): self._items.extend(items) self._randomizer.shuffle(self._items) def pick(self): try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage') def __call__(self): self.pick() 明确指定BingoCage类扩展Tombola类 random.SystemRandom使用os.urandom()实现，os.urandom()函数生成适合用于加密的随机字节序列 BingoCage从Tombola中继承了耗时的loaded方法和笨拙的inspect方法，并没有覆盖 1234567891011121314151617181920212223import randomfrom tombola import Tombolaclass LotteryBlower(Tombola): def __init__(self, iterable): self._balls = list(iterable) # 1 def load(self, iterable): self._balls.extend(iterable) def pick(self): try: position = random.randrange(len(self._balls)) except ValueError: raise LookupError('pick from empty BingoCage') return self._balls.pop(position) def loaded(self): # 2 return bool(self._balls) def inspect(self): return tuple(sorted(self._balls)) 初始化方法接受任何可迭代对象，把参数构建成列表，创建参数的副本，避免原始列表被修改 覆盖loaded方法，避免调用inspect方法，可以直接处理self._balls而不必构建整个有序元组提升速度 Tombola的虚拟子类白鹅类型的一个基本特性：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。 把Tombolist注册为Tombola的虚拟子类，Tombolist是list的真实子类 1234567891011121314151617181920from random import randrangefrom tombola import Tombola@Tombola.register class TomboList(list): def pick(self): if self: position = randrange(len(self)) return self.pop(position) else: raise LookupError('pop from empty TomboList') load = list.extend def loaded(self): return bool(self) def inspect(self): return tuple(sorted(self)) Tombola子类的测试方法123456789101112131415161718192021222324252627import doctestfrom tombola import Tombolaimport bingo, lotto, tombolist, drum # &lt;1&gt;TEST_FILE = 'tombola_tests.rst'TEST_MSG = '&#123;0:16&#125; &#123;1.attempted:2&#125; tests, &#123;1.failed:2&#125; failed - &#123;2&#125;'def main(argv): verbose = '-v' in argv real_subclasses = Tombola.__subclasses__() # &lt;2&gt; virtual_subclasses = list(Tombola._abc_registry) # &lt;3&gt; for cls in real_subclasses + virtual_subclasses: test(cls, verbose)def test(cls, verbose=False): res = doctest.testfile( TEST_FILE, globs=&#123;'ConcreteTombola': cls&#125;, # &lt;4&gt; verbose=verbose, optionflags=doctest.REPORT_ONLY_FIRST_FAILURE) tag = 'FAIL' if res.failed else 'OK' print(TEST_MSG.format(cls.__name__, res, tag)) if __name__ == '__main__': import sys main(sys.argv) 导入包含Tombola真实子类和虚拟子类的模块，用于测试 __subclasses__返回类的真实子类列表，不含虚拟子类 _abc_registry，只有抽象基类有这个数据属性，其值是一个WeakSet对象，即抽象类注册的虚拟子类的弱引用 把cls参数绑定到全局命名空间里的ConcreteTombola名称上，供doctest使用 Python使用register的方式 当作类装饰器使用：@Tombola.register 当作普通函数使用：Sequence.register(tuple) 继承的优缺点子类化内置类型很麻烦在Python2.2之后，内置类型可以子类化了。但是使用C语言编写的内置类型不会调用用户定义的类覆盖的特殊方法。如果子类化使用Python编写的类，就不会受此影响。 内置类型dict的__init__和__update__方法会忽略我们覆盖的__setitem__方法 子类化collections.UserDict不会覆盖掉 多重继承和方法解析顺序任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起的。对于同名方法先找到哪个就调用哪个。 12345678910111213141516171819202122232425262728293031323334class A: def ping(self): print('ping:', self)class B(A): def pong(self): print('pong:', self)class C(A): def pong(self): print('PONG:', self)class D(B, C): def ping(self): super().ping() # 4 # A.ping(self) # 5 print('post-ping:', self) def pingpong(self): self.ping() super().ping() self.pong() super().pong() C.pong(self) &gt;&gt;&gt; from diamond import *&gt;&gt;&gt; d = D()&gt;&gt;&gt; d.pong() # 1pong: &lt;diamond.D object at 0x10066c278&gt;&gt;&gt;&gt; C.pong(d) # 2PONG: &lt;diamond.D object at 0x10066c278&gt;&gt;&gt;&gt; D.__mro__ # 3(&lt;class 'diamond.D'&gt;, &lt;class 'diamond.B'&gt;, &lt;class 'diamond.C'&gt;,&lt;class 'diamond.A'&gt;, &lt;class 'object'&gt;) 调用d.pong()时运行的是B类中的版本，因为Class D(B, C)中，B在C 前 超类中的方法都可以直接调用，此时把实例作为显式参数传入 Python会按照特定的顺序遍历继承图，这个顺序叫方法解析顺序，类都有一个名为__mro__的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直线上知道object类。 若想把方法调用委托给超类，推荐的方式是使用内置的super()函数 有时可能需要绕过方法解析顺序，直接调用某个超类的方法 处理多重继承 把接口继承和实现继承区分开 继承接口，创建子类型，实现“是什么”关系，是框架的支柱 继承实现，通过重用避免代码重复，通常可以换用组合和委托模式 使用抽象基类显式表示接口 现代Python中，如果类的作用是定义接口，应该明确把它定义为抽象基类 通过混入类重用代码 如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现是什么的关系，应该把那个类明确的定义为混入类mixinclass。从概念上讲，混入类不定义新类型，只是打包方法便于重用。混入类绝不能实例化，而且具体类不能只继承混入类。混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。 在名称中明确指明混入 因为在Python中没有把类声明为混入的正规方式，所以强烈推荐在名称中假如...Mixin后缀。 抽象基类可以作为混入，反过来则不成立 抽象基类可以实现具体方法，因此也可以作为混入使用。不过，抽象基类会定义类型，而混入做不到。此外，抽象基类可以作为其他类的唯一基类，而混入绝不能作为唯一超类，除非继承另一个更具体的混入。 不要子类化多个具体类 具体类可以没有或最多只有一个具体超类。也就是说，具体类的超类除了这一个具体超类之外，其余的都是抽象基类或者混入类。 123class MyConcreteClass(Alpha, Beta, Gamma): \"\"\"这是一个具体类，可以实例化。\"\"\" # ……更多代码 为用户提供聚合类 如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用易于理解的方式把它们结合起来。这种类称为聚合类。 123456class Widget(BaseWidget, Pack, Place, Grid): \"\"\"Internal class. Base class for a widget which can be positioned with the geometry managers Pack, Place or Grid.\"\"\" paas Widget类的定义体是空的，但是这个类提供了有用的服务：把四个超类结合在一起，这样创建新小组件的用户无需记住全部混入，也不用担心声明class语句时没有遵守特定的顺序。 优先使用对象组合，而不是类继承 熟悉继承之后，太容易过渡使用。优先使用组合才能让设计更灵活。因为子类化是一种紧耦合，而且较高的继承树容易倒。组合和委托可以代替混入，把行为提供给不同的类，但是不能取代接口继承去定义类型的层次结构。 想想哪些类是真正需要的，我们极少需要编写作为其他类的超类，我们自己编写的类几乎是末端类，当你发现自己在构建多层类层次结构时，你可能在： 你在重新发明轮子，去找框架或库，他们提供的组件可以在应用程序中重用 你使用的框架设计不良，去寻找替代品 你在过读设计，记住要遵守KISS原则 你厌烦了编写应用程序，决定新造一个框架 正确重载运算符运算符重载基础 不能重载内置类型的运算符 不能新建运算符，只能重载现有的 某些运算符不能重载，is、and、or和not不能，&amp;、|和~可以 一元运算符支持一元运算符很简单，只需实现相应的特殊方法。这些特殊方法只有一个参数，self。然后使用符合所在类的逻辑实现，始终返回一个新对象。 12345678def __abs__(self): return math.sqrt(sum(x * x for x in self))def __neg__(self): return Vector(-x for x in self) # &lt;1&gt;def __pos__(self): return Vector(self) # &lt;2&gt; 为了计算-v，构建一个新的Vector实例，把self的每个分量都取反 为了计算+v，构建一个新的Vector实例，传入self的各个分量 重载向量加法运算符+123456789def __add__(self, other): try: pairs = itertools.zip_longest(self, other, fillvalue=0.0) # 1 return Vector(a + b for a, b in pairs) except TypeError: return NotImplemented # 2def __radd__(self, other): # 3 return self + other pairs是个生成器，它会生成(a, b)形式的元组，其中a来自self，b来自other。如果self和other的长度不同，使用fillvalue填充较短那个可迭代对象 如果由于类型不兼容而导致运算符特殊方法无法返回有效的结果，那么应该返回NotImplemented，而不是抛出TpyeError。返回NotImplemented时，另一个操作数所属的类型的还有机会执行运算，而Python会尝试调用反向方法。 如果左操作数没有实现__add__方法或者实现了但是返回NotImplemented表明它不知道如何处理右操作数，那么Python会调用__radd__方法 __radd__直接委托__add__ 重载标量乘法运算符*12345678def __mul__(self, scalar): if isinstance(scalar, numbers.Real): # 1 return Vector(n * scalar for n in self) else: return NotImplementeddef __rmul__(self, scalar): return self * scalar 如果scalar是numbers.Real某个子类的实例，用分量的乘积创建一个新的Vector实例 否则，返回NotImplemented，让Python尝试在scalar操作数上调用__rmul__方法 __rmul__直接委托__mul__ 众多比较运算符123456def __eq__(self, other): if isinstance(other, Vector): # &lt;1&gt; return (len(self) == len(other) and all(a == b for a, b in zip(self, other))) else: return NotImplemented # &lt;2&gt; 如果other操作数是Vector实例，那就像之前那样比较 否则，返回NotImplemnted 增量赋值运算符增量赋值不会修改不可变目标，而是新建实例，然后重新绑定 1234567891011121314151617181920class AddableBingoCage(BingoCage): def __add__(self, other): if isinstance(other, Tombola): return AddableBingoCage(self.inspect() + other.inspect()) else: return NotImplemented def __iadd__(self, other): if isinstance(other, Tombola): other_iterable = other.inspect() # 1 else: try: other_iterable = iter(other) # 2 except TypeError: self_cls = type(self).__name__ msg = \"right operand in += must be &#123;!r&#125; or an iterable\" raise TypeError(msg.format(self_cls)) self.load(other_iterable) return self # 3 如果other是Tombola实例，从中获取元素，否则尝试使用other创建迭代器 如果尝试失败，抛出异常，并告知用户该怎么做。如果可能，错误消息应该明确指导用户怎么解决问题 增量赋值特殊方法必须返回self","tags":[{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"}]},{"title":"Django 部署","date":"2018-05-30T06:54:59.487Z","path":"2018/05/30/Python-Django-Deploy/","text":"uWSGI+django+nginx流程 首先客户端请求服务资源 nginx作为直接对外的服务接口，客户端发送过来的http请求，会解包、分析 如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源 如果是动态的请求，nginx就通过配置文件，将请求传递给uWSGI。uWSGI 将接收到的包进行处理，并转发给wsgi wsgi根据请求调用django工程的某个文件或函数，处理完后django将返回值交给wsgi wsgi将返回值进行打包，转发给uWSGI uWSGI接收后转发给nginx，nginx最终将返回值返回给客户端(如浏览器) 作用 第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程 在nginx上加上安全性或其他的限制，可以达到保护程序的作用 uWSGI本身是内网接口，开启多个work和processes可能也不够用，而nginx可以代理多台uWSGI完成uWSGI的负载均衡 yum源12345678910111213# 配置阿里云的yum源cd /etc/yum.repos.d/mv CentOS-Base.repo CentOS-Base.repo.bakwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache# 配置nginx的yum源rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm# 安装依赖yum groupinstall \"Development tools\"yum install -y zlib-devel bzip2-devel pcre-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel Django创建工程12pip install Djangodjango-admin.py startproject finance 测试工程1234567# cd /home/finance/finance# vim view.pyfrom django.http import HttpResponse def hello(request): return HttpResponse(\"Hello world ! \") 123456789# vim urls.pyfrom django.conf.urls import url from . import view urlpatterns = [ url(r'^$', view.hello),] 12# 运行python manage.py runserver 0.0.0.0:8000 uWSGI安装uwsgi1234pip install uwsgiuwsgi --versionuwsgi uwsgi.ini # 启动uwsgi uwsgi应用测试123456# vim test.pydef application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return [b\"Hello World\"] # python3 #return [\"Hello World\"] # python2 1uwsgi --http :8000 --wsgi-file test.py uwsgi配置文件12345678910111213# mysite_uwsgi.ini file[uwsgi]# Django-related settingshttp = :8001pythonpath = /mnt/tools/accounting_center/trunkwsgi-file = trunk/wsgi.pyprocesses = 2daemonize = /mnt/tools/accounting_center/trunk/log/uwsgi.logvacuum = truepidfile = /mnt/tools/accounting_center/trunk/uwsgi.pidsocket=/mnt/tools/accounting_center/trunk/uwsgi.sockpy-autoreload=10 1234567891011[uwsgi]# Django-related settingshttp = :8000pythonpath = /home/financewsgi-file = finance/wsgi.pyprocesses = 4daemonize = /home/finance/log/uwsgi.logvacuum = truesocket=/home/finance/uwsgi.sockpy-autoreload=1 # 平滑重启 Nginx安装Nginx1234567yum install -y nginx # 安装nginxsystemctl start nginx.service # 启动ngnixsystemctl stop nginx.service # 终止ngnixsystemctl reload nginx.service # 平滑重启ngnixsystemctl restart nginx.service # 重启ngnixsystemctl enable nginx.service # 开机启动 Nginx配置信息1234567891011121314151617181920212223242526# /etc/nginx/nginx.conf# vim /etc/nginx/conf.d/finance.confserver &#123; listen 80; # 我要监听那个端口 server_name 192.168.2.40 ; # 你访问的路径前面的url名称 charset utf-8; # Nginx编码 gzip on; # 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多 gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream; # 支持压缩的类型 error_page 404 /404.html; # 错误页面 error_page 500 502 503 504 /50x.html; # 错误页面 # 指定项目路径uwsgi location / &#123; # 这个location就和咱们Django的url(r'^admin/', admin.site.urls), include uwsgi_params; # 导入一个Nginx模块他是用来和uWSGI进行通讯的 uwsgi_connect_timeout 30; # 设置连接uWSGI超时时间 uwsgi_pass unix:/home/finance/uwsgi.sock; # 指定uwsgi的sock文件所有动态请求就会直接丢给他 &#125; # 指定静态文件路径 location /static/ &#123; alias /home/finance/static/; index index.html index.htm; &#125;&#125; Nginx负载均衡配置 主服务器：192.168.2.37 工作服务器：192.168.2.36，192.168.2.40 负载均衡的作用 转发功能：按照一定算法(权重、轮询)，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量 故障移除：通过心跳检测方式，判断应用服务器当前是否可以正常工作，如果服务器宕机，自动将请求发送到其他应用服务器 恢复添加：如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队列中 配置参数说明主服务器配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960user nginx; worker_processes auto; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events &#123; worker_connections 1024; &#125; http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; upstream finance &#123; server 192.168.2.40:8080; server 192.168.2.36:8080; &#125; server&#123; listen 80; server_name 192.168.2.37; location / &#123; allow 211.161.60.12; allow 59.110.16.204; allow 59.110.11.24; allow 101.201.46.230; allow 101.201.41.72; allow 47.93.175.161; allow 47.93.175.119; deny all; #如果后端的服务器返回502、504、执行超时等错误，自动将请求转发 proxy_next_upstream http_502 http_504 error timeout invalid_header; #对不同的HTTP状态码设置不同的缓存时间 proxy_cache_valid 200 304 12h; proxy_pass http://finance; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125;&#125; 工作服务器配置1234567891011121314151617181920212223 # vim /etc/nginx/conf.d/finance.conf server &#123; listen 8080; server_name 192.168.2.36 ; charset utf-8; gzip on; gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream; error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location / &#123; include uwsgi_params; uwsgi_connect_timeout 30; uwsgi_pass unix:/home/finance/uwsgi.sock; &#125; location /static/ &#123; alias /home/finance/static/; index index.html index.htm; &#125;&#125; 压力测试","tags":[{"name":"Linux","slug":"Linux","permalink":"http://printxhl.com/tags/Linux/"},{"name":"Web","slug":"Web","permalink":"http://printxhl.com/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://printxhl.com/tags/Django/"}]},{"title":"Fluent Python (2)：函数","date":"2018-05-30T06:54:59.188Z","path":"2018/05/30/Python-FlunetPython-function/","text":"一等函数在Python中，函数是一等对象。编程语言理论家把一等对象定义为满足下述条件的程序实体： 在运行时创建 能赋值给变量或数据结构中的元素 能作为参数传给函数 能作为函数的返回结果 把函数视作对象高阶函数123456789101112131415161718192021222324&gt;&gt;&gt; fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']&gt;&gt;&gt; sorted(fruits, key=len)['fig', 'apple', 'cherry', 'banana', 'raspberry', 'strawberry']&gt;&gt;&gt; list(map(fact, range(6))) [1, 1, 2, 6, 24, 120]&gt;&gt;&gt; [fact(n) for n in range(6)] [1, 1, 2, 6, 24, 120]&gt;&gt;&gt; list(map(factorial, filter(lambda n: n % 2, range(6)))) [1, 6, 120]&gt;&gt;&gt; [factorial(n) for n in range(6) if n % 2] [1, 6, 120]&gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; from operator import add &gt;&gt;&gt; reduce(add, range(100)) 4950&gt;&gt;&gt; sum(range(100)) 4950&gt;&gt;&gt; all([1, 1, 0, 1])False&gt;&gt;&gt; any([1, 1, 0, 1])True 匿名函数12&gt;&gt;&gt; fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry']&gt;&gt;&gt; sorted(fruits, key=lambda word: word[::-1]) 可调用对象 用户定义的函数：使用def语句或lambda表达式创建 内置函数：使用C语言(CPython)实现的函数，如len 内置方法：使用C语言实现的方法，如dict.get 方法：在类的定义体中定义的函数 类：调用类时会运行类的__new__方法创建一个实例，然后运行__init__方法，初始化实例，最后把实例返回给调用方 类的实例：如果类定义了__call__方法，那么它的实例可以作为函数调用 生成器函数：使用yield关键字的函数或方法。调用生成器函数返回的是生成器对象 用户定义的可调用类型123456789101112131415161718import randomclass BingoCage: def __init__(self, items): self._items = list(items) random.shuffle(self._items) def pick(self): try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage') def __call__(self): return self.pick()bingo = BingoCage(range(3)) bingo.pick()的快捷方式是bingo() 函数的内省dir(factorial)，获取函数属性 从定位参数到仅限关键字参数12345678910111213141516171819202122232425262728293031def tag(name, *content, cls=None, **attrs): \"\"\"Generate one or more HTML tags\"\"\" if cls is not None: attrs['class'] = cls if attrs: attr_str = ''.join(' %s=\"%s\"' % (attr, value) for attr, value in sorted(attrs.items())) else: attr_str = '' if content: return '\\n'.join('&lt;%s%s&gt;%s&lt;/%s&gt;' % (name, attr_str, c, name) for c in content) else: return '&lt;%s%s /&gt;' % (name, attr_str) &gt;&gt;&gt; tag('br') # 1'&lt;br /&gt;'&gt;&gt;&gt; tag('p', 'hello') # 2 '&lt;p&gt;hello&lt;/p&gt;'&gt;&gt;&gt; print(tag('p', 'hello', 'world'))&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;world&lt;/p&gt;&gt;&gt;&gt; tag('p', 'hello', id=33) # 3 '&lt;p id=\"33\"&gt;hello&lt;/p&gt;'&gt;&gt;&gt; print(tag('p', 'hello', 'world', cls='sidebar')) # 4 &lt;p class=\"sidebar\"&gt;hello&lt;/p&gt;&lt;p class=\"sidebar\"&gt;world&lt;/p&gt;&gt;&gt;&gt; tag(content='testing', name=\"img\") # 5'&lt;img content=\"testing\" /&gt;'&gt;&gt;&gt; my_tag = &#123;'name': 'img', 'title': 'Sunset Boulevard','src': 'sunset.jpg', 'cls': 'framed'&#125;&gt;&gt;&gt; tag(**my_tag) # 6'&lt;img class=\"framed\" src=\"sunset.jpg\" title=\"Sunset Boulevard\" /&gt;' 传入单个定位参数，生成一个指定名称的空标签 第一个参数后面的任意个参数会被*content捕获，存入一个元祖 tag函数签名中没有明确指定名称的关键字参数会被**attrs捕获，存入一个字典 cls参数只能作为关键字参数传入 调用tag函数时，即便第一个参数也能作为关键字参数传入 在my_tag前面加上**，字典中所有元素作为单个参数传入，同名键会绑定到对应的具名参数上，余下的则被**attrs捕获 获取关于参数的信息12345678910111213141516171819202122232425def clip(text, max_len=80): \"\"\"Return text clipped at the last space before or after max_len \"\"\" end = None if len(text) &gt; max_len: space_before = text.rfind(' ', 0, max_len) if space_before &gt;= 0: end = space_before else: space_after = text.rfind(' ', max_len) if space_after &gt;= 0: end = space_after if end is None: # no spaces were found end = len(text) return text[:end].rstrip()&gt;&gt;&gt; from clip import clip&gt;&gt;&gt; clip.__defaults__ # 1(80,)&gt;&gt;&gt; clip.__code__ &lt;code object clip at 0x...&gt;&gt;&gt;&gt; clip.__code__.co_varnames # 2('text', 'max_len', 'end', 'space_before', 'space_after')&gt;&gt;&gt; clip.__code__.co_argcount # 32 __defaults__属性，它的值是一个元组，里面保存着定位参数和关键字参数的默认值 __code__.co_varnames，它的值是一个元组，里面参数名称以及函数定义体中创建的局部变量 __code__.co_argcount，参数的数目 函数注解1234567891011121314151617def clip(text:str, max_len:'int &gt; 0'=80) -&gt; str: # &lt;1&gt; \"\"\"Return text clipped at the last space before or after max_len \"\"\" end = None if len(text) &gt; max_len: space_before = text.rfind(' ', 0, max_len) if space_before &gt;= 0: end = space_before else: space_after = text.rfind(' ', max_len) if space_after &gt;= 0: end = space_after if end is None: # no spaces were found end = len(text) return text[:end].rstrip()print(clip.__annotations__) # 2 函数声明中的各个参数可以在:之后增加注解表达式。如果参数有默认值，注解放在参数名和=号之间。如果想注解返回值，使用-&gt;和一个表达式。 __annotations__，存储函数的注解 支持函数式编程的包operator模块1234567891011121314151617181920212223242526272829from functools import reducefrom operator import mul # 1def fact(n): return reduce(mul, range(1, n+1))&gt;&gt;&gt; metro_data = [... ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),... ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),... ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),... ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),... ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),... ]from operator import itemgetter for city in sorted(metro_data, key=itemgetter(1)): print(city) cc_name = itemgetter(1, 0) # 2for city in metro_data: print(cc_name(city))&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; LatLong = namedtuple('LatLong', 'lat long') &gt;&gt;&gt; Metropolis = namedtuple('Metropolis', 'name cc pop coord') &gt;&gt;&gt; metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) ... for name, cc, pop, (lat, long) in metro_data]&gt;&gt;&gt; from operator import attrgetter &gt;&gt;&gt; name_lat = attrgetter('name', 'coord.lat') # 3&gt;&gt;&gt; for city in sorted(metro_areas, key=attrgetter('coord.lat')): ... print(name_lat(city)) operator模块为多个算术运算符提供了对应的函数 itemgetter(1, 0)等价于lambda x: x[1], x[0] attrgetter(&#39;name&#39;, &#39;coord.lat&#39;)等价于lambda x: x[&#39;name&#39;], x[&#39;coord.lat&#39;] 使用functools.partial冻结参数123456789101112131415161718&gt;&gt;&gt; from operator import mul&gt;&gt;&gt; from functools import partial&gt;&gt;&gt; triple = partial(mul, 3) # 1&gt;&gt;&gt; triple(7) 21&gt;&gt;&gt; list(map(triple, range(1, 10))) [3, 6, 9, 12, 15, 18, 21, 24, 27]&gt;&gt;&gt; import unicodedata, functools&gt;&gt;&gt; nfc = functools.partial(unicodedata.normalize, 'NFC') # 2&gt;&gt;&gt; s1 = 'café'&gt;&gt;&gt; s2 = 'cafe\\u0301'&gt;&gt;&gt; s1, s2('café', 'café')&gt;&gt;&gt; s1 == s2False&gt;&gt;&gt; nfc(s1) == nfc(s2)True 使用mul创建triple函数，把第一个定位参数定为3 partial的第一个参数是一个可调用对象，后面跟着任意个要绑定的定位参数和关键字参数 使用一等函数实现设计模式重构策略模式经典的策略模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from abc import ABC, abstractmethodfrom collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion.discount(self) return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())class Promotion(ABC): # the Strategy: an Abstract Base Class @abstractmethod def discount(self, order): \"\"\"Return discount as a positive dollar amount\"\"\"class FidelityPromo(Promotion): # first Concrete Strategy \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" def discount(self, order): return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0class BulkItemPromo(Promotion): # second Concrete Strategy \"\"\"10% discount for each LineItem with 20 or more units\"\"\" def discount(self, order): discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discountclass LargeOrderPromo(Promotion): # third Concrete Strategy \"\"\"7% discount for orders with 10 or more distinct items\"\"\" def discount(self, order): distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0 使用函数实现策略模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) # &lt;1&gt; return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())def fidelity_promo(order): # &lt;2&gt; \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0def bulk_item_promo(order): \"\"\"10% discount for each LineItem with 20 or more units\"\"\" discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discountdef large_order_promo(order): \"\"\"7% discount for orders with 10 or more distinct items\"\"\" distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0 选择最佳策略：简单方式123456promos = [fidelity_promo, bulk_item_promo, large_order_promo] # &lt;1&gt;def best_promo(order): # &lt;2&gt; \"\"\"Select best discount available \"\"\" return max(promo(order) for promo in promos) # &lt;3&gt; 找出模块中的全部策略1234567891011promos = [globals()[name] for name in globals() # 1 if name.endswith('_promo') and name != 'best_promo'] promos = [func for name, func in inspect.getmembers(promotions, inspect.isfunction)] # 2def best_promo(order): \"\"\"Select best discount available \"\"\" return max(promo(order) for promo in promos) # &lt;4&gt; 使用globals函数内省，构建promos列表 使用inspect.getmembers函数获取对象属性，第二个参数是可选的判断条件 命令模式12345678class MacroCommand: \"\"\"一个执行一组命令的命令\"\"\" def __init__(self, commands): self.commands = list(commands) # 1 def __call__(self): for command in self.commands: # 2 command() 使用commands参数构建一个列表，这样能确保参数是可迭代对象，还能在各个MacroCommand实例中保存各个命令引用的副本 调用MacroCommand实例时，self.commands中的各个命令依序执行 函数装饰器和闭包装饰器基础知识12345678def deco(func): def inner(): print('running inner()') return inner@decodef target(): print('running target()') target()等价于deco(target) Python何时执行装饰器123456789101112131415161718192021222324252627registry = [] def register(func): print('running register(%s)' % func) registry.append(func) return func @register def f1(): print('running f1()')@registerdef f2(): print('running f2()')def f3(): print('running f3()')def main(): print('running main()') print('registry -&gt;', registry) f1() f2() f3()if __name__=='__main__': main() 函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行 装饰器函数与被装饰的函数在同一个模块中定义，实际上装饰器通常在一个模块中定义，然后应用到其他模块中的函数上 register装饰器返回的函数与通过参数传入的相同，实际上大多数装饰器会在内部定义一个函数，然后将其返回 使用装饰器改进策略模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())promos = [] # &lt;1&gt;def promotion(promo_func): # &lt;2&gt; promos.append(promo_func) return promo_func@promotion # &lt;3&gt;def fidelity(order): \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0@promotiondef bulk_item(order): \"\"\"10% discount for each LineItem with 20 or more units\"\"\" discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discount@promotiondef large_order(order): \"\"\"7% discount for orders with 10 or more distinct items\"\"\" distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0def best_promo(order): # &lt;4&gt; \"\"\"Select best discount available \"\"\" return max(promo(order) for promo in promos) 变量作用域规则1234567891011121314151617181920&gt;&gt;&gt; b = 6&gt;&gt;&gt; def f2(a):... print(a)... print(b)... b = 9&gt;&gt;&gt; f2(3)3Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 3, in f2UnboundLocalError: local variable 'b' referenced before assignme # 1&gt;&gt;&gt; b = 6&gt;&gt;&gt; def f3(a):... global b # 2... print(a)... print(b)... b = 9&gt;&gt;&gt; f3(3)3 Python在编译函数时，假定在函数定义体中赋值的变量是局部变量。也就是说，它判断b为局部变量，但在打印时，b没有绑定值，所以报错 使用global声明全局变量 闭包123456789class Averager(): def __init__(self): self.series = [] def __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total/len(self.series) 以上是类实现，一下是函数式实现，即闭包 123456789def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager series是make_averager函数的局部变量，在调用avg(10)时，make_averager函数已经返回，本地作用域消失。seriers则成了自由变量。 闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但仍能使用那些绑定。 nonlocal声明1234567891011def make_averager(): count = 0 total = 0 def averager(new_value): nonlocal count, total count += 1 total += new_value return total / count return averag nonlocal声明，把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。 实现一个简单的装饰器简单版本1234567891011121314151617181920212223242526import timedef clock(func): def clocked(*args): t0 = time.time() result = func(*args) elapsed = time.time() - t0 name = func.__name__ arg_str = ', '.join(repr(arg) for arg in args) print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result)) return result return clocked@clockdef snooze(seconds): time.sleep(seconds)@clockdef factorial(n): return 1 if n &lt; 2 else n*factorial(n-1)if __name__=='__main__': print('*' * 40, 'Calling snooze(.123)') snooze(.123) print('*' * 40, 'Calling factorial(6)') print('6! =', factorial(6)) 改进版本1234567891011121314151617181920import timeimport functoolsdef clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.time() result = func(*args, **kwargs) elapsed = time.time() - t0 name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[%0.8fs] %s(%s) -&gt; %r ' % (elapsed, name, arg_str, result)) return result return clock 原版本不支持关键字参数，而且遮盖了被装饰函数的__name__和__doc__属性。functools.wraps装饰器把相关属性从func复制到clocked中。 标准库中的装饰器使用functools.lru_cache做备忘123456789101112import functoolsfrom clockdeco import clock@functools.lru_cache() # 1@clock # 2def fibonacci(n): if n &lt; 2: return n return fibonacci(n-2) + fibonacci(n-1)if __name__ == '__main__': print(fibonancci(6)) functools.lru_cache实现了备忘功能，把耗时函数的结果保存起来，避免传入相同的参数时重复计算。带括号是因为lru_cache可以接受配置参数 叠放了装饰器，@lru_cache()应用到@clock返回的函数上 单分派泛函数123456789101112131415161718192021222324from functools import singledispatch from collections import abcimport numbersimport html@singledispatch # 1def htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'.format(content)@htmlize.register(str) # 2def _(text): # 3 content = html.escape(text).replace('\\n', '&lt;br&gt;\\n') return '&lt;p&gt;&#123;0&#125;&lt;/p&gt;'.format(content)@htmlize.register(numbers.Integral) def _(n): return '&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'.format(n)@htmlize.register(tuple) # 4@htmlize.register(abc.MutableSequence)def _(seq): inner = '&lt;/li&gt;\\n&lt;li&gt;'.join(htmlize(item) for item in seq) return '&lt;ul&gt;\\n&lt;li&gt;' + inner + '&lt;/li&gt;\\n&lt;/ul&gt;' 使用@singledispath装饰的普通函数会变成泛函数：根据第一个参数的类型，以不同方式执行相同操作的一族函数 各个专门函数使用@{base_function}.register({type})装饰 专门函数的名称无关紧要：_是一个不错的选择，简单明了 可以叠放多个register装饰器，让同一个函数支持不同的类型 叠放装饰器1234@d1@d2def f(): print('f') 等同于： 1234def f(): print('f') f = d1(d2(f)) 参数化装饰器参数化注册装饰器1234567891011121314151617181920212223registry = set() # 1def register(active=True): def decorate(func): # 2 print('running register(active=%s)-&gt;decorate(%s)' % (active, func)) if active: # registry.add(func) else: registry.discard(func) return func return decorate # 3@register(active=False) def f1(): print('running f1()')@register() # 4def f2(): print('running f2()')def f3(): print('running f3()') registry现在是个set对象，这样添加和删除函数的速度更快 decorate这个内部函数是真正的装饰器，它的参数必须是一个函数，并且必须返回一个函数 registrer是装饰器工厂函数，因此返回decorate @register工厂函数必须作为函数调用，并且传入所需的参数，即使不传入参数，register也必须作为函数调用，如@register()，即要返回真正的装饰器decorate 参数化clock函数1234567891011121314151617181920212223242526import timeDEFAULT_FMT = '[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'def clock(fmt=DEFAULT_FMT): def decorate(func): def clocked(*_args): t0 = time.time() _result = func(*_args) elapsed = time.time() - t0 name = func.__name__ args = ', '.join(repr(arg) for arg in _args) # 1 result = repr(_result) # 2 print(fmt.format(**locals())) # 3 return _result return clocked return decorate if __name__ == '__main__': @clock() def snooze(seconds): time.sleep(seconds) for i in range(3): snooze(.123) _args是clocked的参数，args是用于显示的字符串 result是_result的字符串表示形式，用于显示 locals()存储着clocked的局部变量，供格式化使用","tags":[{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"}]},{"title":"Elasticsearch 部署","date":"2018-05-30T06:54:56.836Z","path":"2018/05/30/SearchEngine-Elasticsearch-Ready/","text":"ES 概述Near Realtimehttp://www.ruanyifeng.com/blog/2017/08/elasticsearch.html https://blog.csdn.net/zwgdft/article/details/54585644 https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html https://blog.csdn.net/kongxx/article/details/52993057 https://blog.csdn.net/sinat_28224453/article/details/51134978 https://blog.csdn.net/zlghitler/article/details/1523645 ES 安装安装 ES12345678910111213141516171819# 安装Javayum install -y java-1.8.0-openjdk-devel# 添加es用户, root启动es会报错useradd espasswd es# 给es用户添加sudo权限$ vim /etc/sudoers # 修改wheel%wheel ALL=(ALL) NOPASSWD: ALLusermod -G wheel es# 安装Essu - esmdkir &#123;data, logs&#125; # 用于存入数据和日志，避免使用系统盘wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.zipunzip elasticsearch-6.2.4.zipsudo mv elasticsearch-6.2.4 /usr/local/sudo ln -sf /usr/local/elasticserch /usr/local/es 配置 ES1234567891011121314# 配置ES$ vim /usr/local/es/config/elasticsearch.ymlpath.data: /home/es/data # 数据存放路径path.logs: /home/es/logs # 日志存放路径cluster.name: elasticsearch # 集群名node.name: node-2 # 节点名，唯一network.host: 192.168.3.56 # 绑定域名，默认为环回地址127.0.0.1discovery.zen.ping.unicast.hosts: [\"192.168.3.55\", \"192.168.3.57\"] # 广播地址，发现集群节点discovery.zen.minimum_master_nodes: 2 # 避免脑裂问题，一个节点需要看到的具有master节点资格的最小数量，然后才能在集群中操作，推荐(N/2)+1# 配置jvm, zero-based compressed oops$ vim /usr/local/es/config/jvm.options-Xms2g-Xmx2g 系统配置12345678910111213141516171819# 避免使用内存交换sudo swapoff -a # 关闭系统的内存交换$ vim /usr/local/es/config/elasticsearch.ymlbootstrap.memory_lock: true # 或者禁止es使用内存交换空间# 提高进程可以打开文件的最大数ulimit -n 65536 # 暂时的$ vim /etc/security/limits.conf # 或者永久的es - nofile 65536# 提高虚拟内存sysctl -w vm.max_map_count=262144 # 暂时的$ vim /etc/sysctl.conf # 或者永久的vm.max_map_count=262144# 提高并发数ulimit -u 4096 # 暂时的$ vim /etc/security/limits.conf # 或者永久的es - nproc 4096 启动与停止123456789# 启动，后台运行，记录pid/usr/local/es/bin/elasticsearch -d -p pid# 停止cat /usr/local/es/pid | xargs kill -9# 简易版的开机自启动$ vim /etc/rc.local/usr/local/es/bin/elasticsearch -d -p pid ES插件安装各种插件的安装 head123456789101112131415161718192021222324252627282930# 修改elasticsearch.yml, 修改完后要重启的$ vim /usr/local/es/config/elasticsearch.ymlhttp.cors.enabled: true http.cors.allow-origin: \"*\"# 下载head插件cd /home/es/tools # 不能安装在es的plugins目录下，启动报错wget https://github.com/mobz/elasticsearch-head/archive/master.zipupzip master.zip -d ../mv elasticsearch-head-mater head# 修改head插件源码$ vim /home/es/head/Gruntfile.js # 修改服务器监听地址connect: &#123; server: &#123; options: &#123; port: 9100, base: '.', keepalive: true, hostname: '*' &#125; &#125; &#125; # 安装node，启动cd /home/es/headyum install nodejsnpm installnpm run start &amp; kibana12345678910111213# 下载kibanacd /home/eswget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gztar -zvxf kibana-6.2.4-linux-x86_64.tar.gzmv kibana-6.2.4-linux-x86_64/ kibana# 更改kibana配置$ vim /home/es/kibana/kibana.ymlserver.host: 192.168.3.56elasticsearch.url: \"http://192.168.3.56:9200\"# 启动nohup /home/es/kibana/bin/kibana &amp; ik分词器1234567891011# 下载ik，对应es版本cd /home/toolswget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zipunzip elasticsearch-analysis-ik-6.2.4.zipmv elasticsearch /usr/local/es/plugins# 重启es,并测试，分词器ik_max_word和ik_smartcurl -XGET -H 'Content-Type: application/json' 'http://192.168.0.83:9200/_analyze?pretty' -d '&#123;\"analyzer\" : \"ik_max_word\", \"text\": \"中华人民共和国国歌\"&#125;' 一些问题 当集群中的节点变多时，就需要指定专用节点做特定的工作，参考node Master-eligible node Data node Ingest node Tribe node Coordinating node","tags":[{"name":"SE","slug":"SE","permalink":"http://printxhl.com/tags/SE/"}]},{"title":"RabbitMQ","date":"2018-05-30T06:54:56.425Z","path":"2018/05/30/Tool-RabbitMQ/","text":"RabbitMQ 安装安装 Erlang12345678910# 添加erlang solutions源，安装最新版本wget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpmrpm -Uvh erlang-solutions-1.0-1.noarch.rpm # -U表示安装包，-vh表示显示进度yum install erlang # 这里有个报错，不知道什么鬼：[Errno -1] Metadata file does not match checksum# 限制版本，避免被yum升级yum install yum-plugin-versionlockyum versionlock erlang* 安装 RabbitMQ12wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7.noarch.rpmyum install rabbitmq-server-3.7.4-1.el7.noarch.rpm 配置 RabbitMQ12345678910111213141516171819202122232425262728$ sudo systemctl enable rabbitmq-server # 添加开机启动RabbitMQ服务$ sudo systemctl start rabbitmq-server # 启动服务$ sudo systemctl status rabbitmq-server # 查看服务状态$ sudo systemctl stop rabbitmq-server # 停止服务# 查看当前所有用户$ sudo rabbitmqctl list_users# 查看默认guest用户的权限$ sudo rabbitmqctl list_user_permissions guest# 由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 先删掉默认用户$ sudo rabbitmqctl delete_user guest# 添加新用户$ sudo rabbitmqctl add_user username password# 设置用户tag$ sudo rabbitmqctl set_user_tags username administrator# 赋予用户默认vhost的全部操作权限$ sudo rabbitmqctl set_permissions -p / username \".*\" \".*\" \".*\"# 查看用户的权限$ sudo rabbitmqctl list_user_permissions username# 开启web管理接口, http://localhost:15672sudo rabbitmq-plugins enable rabbitmq_management RabbitMQ 配置文件12vim /etc/rabbitmq/rabbitmq.conf# https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example http://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html","tags":[{"name":"Web","slug":"Web","permalink":"http://printxhl.com/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://printxhl.com/tags/Python/"},{"name":"MQ","slug":"MQ","permalink":"http://printxhl.com/tags/MQ/"}]}]